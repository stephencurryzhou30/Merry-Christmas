<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Merry Christmas from Zhou</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
            touch-action: none; /* Èò≤Ê≠¢Ëß¶Êë∏Êìç‰Ωú */
        }
        
        body {
            background: radial-gradient(circle at center, #1a1a3a 0%, #03030c 100%);
            font-family: 'Great Vibes', cursive;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: pointer; 
        }
        
        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #loading {
            position: fixed;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4ECDC4;
            font-size: 20px;
            z-index: 10;
            transition: opacity 0.5s;
            font-family: 'Arial', sans-serif;
        }

        #textContainer {
            position: fixed;
            bottom: 3%; 
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
            mix-blend-mode: screen;
        }

        #mainText {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(48px, 6vw, 72px);
            font-weight: 400;
            letter-spacing: 3px;
            color: #FFD700;
            text-shadow: 
                0 0 10px rgba(255, 215, 0, 0.8),
                0 0 20px rgba(255, 215, 0, 0.6),
                0 0 30px rgba(255, 215, 0, 0.4),
                0 0 40px rgba(255, 107, 157, 0.3),
                0 5px 15px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateY(30px);
            animation: textFloatIn 2s ease-out forwards 1s;
            position: relative;
            display: inline-block;
        }

        @keyframes textFloatIn {
            0% { opacity: 0; transform: translateY(30px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes textGlow {
            0%, 100% { 
                text-shadow: 
                    0 0 10px rgba(255, 215, 0, 0.8),
                    0 0 20px rgba(255, 215, 0, 0.6),
                    0 0 30px rgba(255, 215, 0, 0.4),
                    0 0 40px rgba(255, 107, 157, 0.3),
                    0 5px 15px rgba(0, 0, 0, 0.5);
            }
            50% { 
                text-shadow: 
                    0 0 15px rgba(255, 215, 0, 1),
                    0 0 25px rgba(255, 215, 0, 0.8),
                    0 0 35px rgba(255, 215, 0, 0.6),
                    0 0 45px rgba(255, 107, 157, 0.5),
                    0 5px 15px rgba(0, 0, 0, 0.5);
            }
        }

        #mainText {
            animation: 
                textFloatIn 2s ease-out forwards 1s,
                textGlow 3s ease-in-out infinite 3s;
        }

        .tap-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 215, 0, 0.8);
            font-size: 18px;
            font-family: 'Arial', sans-serif;
            text-align: center;
            z-index: 5;
            animation: pulseHint 2s ease-in-out infinite;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        @keyframes pulseHint {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* ÊâãÊú∫Á´Ø‰ºòÂåñ */
        @media screen and (max-width: 768px) {
            #mainText {
                font-size: clamp(40px, 8vw, 56px) !important;
                text-shadow: 
                    0 0 8px rgba(255, 215, 0, 0.8),
                    0 0 16px rgba(255, 215, 0, 0.6),
                    0 0 24px rgba(255, 215, 0, 0.4) !important;
            }
            
            #textContainer {
                bottom: 8% !important;
                gap: 15px;
            }
            
            .tap-hint {
                font-size: 16px;
            }
        }

        /* Ê®™Â±è‰ºòÂåñ */
        @media screen and (orientation: landscape) {
            #mainText {
                font-size: clamp(40px, 5vw, 60px) !important;
            }
            
            #textContainer {
                bottom: 5% !important;
            }
        }

        /* Â∞èÂ±èÂπï‰ºòÂåñ */
        @media screen and (max-height: 500px) {
            #mainText {
                font-size: clamp(36px, 5vw, 48px) !important;
                bottom: 2% !important;
            }
            
            #textContainer {
                bottom: 1% !important;
            }
            
            .tap-hint {
                font-size: 14px;
                top: 20px;
                transform: translateX(-50%);
            }
        }

        /* ÂÖ®Â±èÊ†∑Âºè */
        :fullscreen, ::backdrop {
            background-color: transparent;
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="christmasCanvas"></canvas>
        <div id="loading"></div>
        <div id="textContainer">
            <div id="mainText">Merry ChristmasüéÑ</div>
        </div>
        <div class="tap-hint" id="tapHint"></div>
    </div>

    <script>
        // Ê£ÄÊµãËÆæÂ§áÁ±ªÂûã
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTablet = /iPad|Tablet|PlayBook|Silk/i.test(navigator.userAgent);
        const isLandscape = window.innerWidth > window.innerHeight;

        function requestFullscreen() {
            const elem = document.documentElement;
            
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { 
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { 
                elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { 
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { 
                document.msExitFullscreen();
            }
        }

        function toggleFullscreen() {
            const isFullscreen = document.fullscreenElement || 
                                document.webkitFullscreenElement || 
                                document.msFullscreenElement;
            
            if (!isFullscreen) {
                requestFullscreen();
            } else {
                exitFullscreen();
            }
        }

        function showTapHint() {
            const tapHint = document.getElementById('tapHint');
            setTimeout(() => {
                tapHint.style.opacity = '1';
            }, 3000);
            
            setTimeout(() => {
                tapHint.style.opacity = '0';
            }, 8000);
        }

        class ChristmasAnimation {
            constructor() {
                this.canvas = document.getElementById('christmasCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.resizeTimeout = null;
                this.isFullscreen = false;
                
                // Ê†πÊçÆËÆæÂ§áÁ±ªÂûãË∞ÉÊï¥ÂèÇÊï∞
                this.isMobileDevice = isMobile;
                this.isTabletDevice = isTablet;
                this.isLandscapeMode = isLandscape;
                
                // ÊÄßËÉΩ‰ºòÂåñÂèÇÊï∞
                this.performanceMultiplier = this.isMobileDevice ? 0.7 : 1;
                if (this.isTabletDevice) {
                    this.performanceMultiplier = 0.85;
                }
                
                // Âä®ÁîªÂèÇÊï∞ - ‰øÆÂ§çÔºöÁ°Æ‰øùËá™Âä®ÊóãËΩ¨ÈÄüÂ∫¶
                this.autoRotation = 0;
                this.rotationSpeed = 0.005; // Âõ∫ÂÆöÊóãËΩ¨ÈÄüÂ∫¶ÔºåÁ°Æ‰øùËá™Âä®ÊóãËΩ¨
                this.growthProgress = 0; 
                this.maxGrowth = 1; 
                
                this.setupCanvas();
                this.initColors();
                this.createScene();
                this.startAnimation();
                
                this.preventScroll();
                
                window.addEventListener('resize', () => this.handleResize());
                
                showTapHint();
                
                this.setupFullscreenListeners();
                
                // ÊÄßËÉΩÁõëÊéß
                this.lastDrawTime = 0;
                this.frameCount = 0;
                this.fps = 60;
                
                // Âä®ÁîªÂ∏ßID
                this.animationFrameId = null;
            }

            setupCanvas() {
                const getScreenDimensions = () => {
                    return {
                        width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                        height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                    };
                };
                
                const { width, height } = getScreenDimensions();
                
                // ËÆæÂ§áÂÉèÁ¥†ÊØî‰ºòÂåñ
                this.dpr = Math.min(window.devicePixelRatio || 1, this.isMobileDevice ? 2.5 : 3);
                this.screenWidth = width;
                this.screenHeight = height;
                
                // Á°Æ‰øùcanvasÂ∞∫ÂØ∏‰∏∫Êï¥Êï∞
                this.canvas.width = Math.round(this.screenWidth * this.dpr);
                this.canvas.height = Math.round(this.screenHeight * this.dpr);
                this.canvas.style.width = `${this.screenWidth}px`;
                this.canvas.style.height = `${this.screenHeight}px`;
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(this.dpr, this.dpr);
                
                this.centerX = this.screenWidth / 2;
                this.centerY = this.screenHeight / 2;
                
                // Ëá™ÈÄÇÂ∫îÊ†ëÁöÑÂ§ßÂ∞è
                const baseSize = Math.min(this.screenWidth, this.screenHeight);
                const referenceSize = Math.min(850, Math.max(500, baseSize));
                this.treeScale = baseSize / referenceSize;
                
                // ÊâãÊú∫Á´ñÂ±èË∞ÉÊï¥
                if (this.screenHeight > this.screenWidth * 1.5) {
                    this.treeScale *= 0.9;
                }
                
                // ÊâãÊú∫Ê®™Â±èË∞ÉÊï¥
                if (this.isLandscapeMode && this.isMobileDevice) {
                    this.treeScale *= 0.85;
                }
                
                this.trunkBaseY = this.screenHeight * 0.7;
                this.crownBaseY = this.screenHeight * 0.82;
                
                // ÈöêËóèÂä†ËΩΩÊèêÁ§∫
                setTimeout(() => {
                    this.loading.style.opacity = 0;
                    setTimeout(() => {
                        this.loading.style.display = 'none';
                    }, 500);
                }, 1500);
            }

            setupFullscreenListeners() {
                document.addEventListener('click', (e) => {
                    // Èò≤Ê≠¢Â§öÊ¨°ÁÇπÂáª
                    if (e.target.closest('#canvasContainer')) {
                        toggleFullscreen();
                        document.getElementById('tapHint').style.opacity = '0';
                    }
                });
                
                // Ëß¶Êë∏‰∫ã‰ª∂Â§ÑÁêÜ
                let touchStartY = 0;
                document.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                }, { passive: true });
                
                document.addEventListener('touchmove', (e) => {
                    // Èò≤Ê≠¢È°µÈù¢ÊªöÂä®
                    if (e.touches.length === 1) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('msfullscreenchange', () => this.handleFullscreenChange());
                
                // ÂèåÂáªÂàáÊç¢ÂÖ®Â±è
                let lastTap = 0;
                document.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        toggleFullscreen();
                    }
                    lastTap = currentTime;
                });
            }

            handleFullscreenChange() {
                this.isFullscreen = !!(document.fullscreenElement || 
                                      document.webkitFullscreenElement || 
                                      document.msFullscreenElement);
                
                // ÈáçÊñ∞Ë∞ÉÊï¥ÁîªÂ∏ÉÂ§ßÂ∞è
                setTimeout(() => {
                    this.handleResize();
                }, 100);
            }

            handleResize() {
                if (this.resizeTimeout) {
                    clearTimeout(this.resizeTimeout);
                }
                
                this.resizeTimeout = setTimeout(() => {
                    this.isLandscapeMode = window.innerWidth > window.innerHeight;
                    this.setupCanvas();
                    this.createScene();
                    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
                }, 250);
            }

            preventScroll() {
                // Èò≤Ê≠¢Ëß¶Êë∏ÊªöÂä®
                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Èò≤Ê≠¢Èº†Ê†áÊªöËΩÆ
                document.addEventListener('wheel', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                // Èò≤Ê≠¢ÈîÆÁõòÊªöÂä®
                document.addEventListener('keydown', (e) => {
                    if ([32, 37, 38, 39, 40].includes(e.keyCode)) {
                        e.preventDefault();
                    }
                });
            }

            initColors() {
                this.TREE_COLORS = ["#2E8B57", "#3CB371", "#20B2AA", "#66CDAA", "#00FA9A"];
                this.LIGHT_COLORS = ["#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", "#FFA552", "#93FF9B"];
                this.TRUNK_COLORS = ["#5C3317", "#6F4E37", "#8B4513"];
                this.GIFT_COLORS = [
                    { box: "#FF6B6B", ribbon: "#FFD166" },
                    { box: "#4ECDC4", ribbon: "#FFE66D" },
                    { box: "#95E1D3", ribbon: "#F38181" },
                    { box: "#FF8AF0", ribbon: "#7CE6E6" },
                    { box: "#FFD166", ribbon: "#FF6B9D" },
                    { box: "#A8E6CF", ribbon: "#FFAAA5" },
                    { box: "#FFD3B6", ribbon: "#A8E6CF" },
                    { box: "#D4A5A5", ribbon: "#FFE8E8" },
                ];
                this.SPIRAL_LIGHT_COLORS = [
                    "#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", 
                    "#4ECDC4", "#95E1D3", "#A8E6CF", "#FFD3B6"
                ];
            }

            createScene() {
                this.particles = []; 
                this.lights = [];    
                this.snowflakes = [];
                this.stars = [];     
                this.topStar = null;
                this.gifts = [];     
                this.upperGifts = []; 
                this.topGifts = [];   
                this.spiralLights = [];

                // Ê†πÊçÆËÆæÂ§áÊÄßËÉΩË∞ÉÊï¥Á≤íÂ≠êÊï∞Èáè
                const trunkMultiplier = this.performanceMultiplier;
                const particleMultiplier = this.performanceMultiplier;
                const giftMultiplier = this.performanceMultiplier;
                
                this.createChristmasTreeTrunk(trunkMultiplier);
                this.createChristmasTreeCrown(particleMultiplier);
                this.createSnowflakes();
                this.createTopStar();
                this.createTopGifts(giftMultiplier);    
                this.createUpperGifts(giftMultiplier);  
                this.createGifts(giftMultiplier);      
                this.createSpiralLights(particleMultiplier);
            }

            createChristmasTreeTrunk(multiplier = 1) {
                const trunkHeight = 140 * this.treeScale; 
                const trunkRadius = 50 * this.treeScale; 
                const trunkCount = Math.floor(1000 * multiplier); 
                
                for (let i = 0; i < trunkCount; i++) {
                    const p = i / trunkCount;
                    const y = this.trunkBaseY + p * trunkHeight;
                    const angle = i * 2.39996;
                    const currentRadius = trunkRadius * (1 - 0.2 * p);
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.5 + Math.random() * 0.5);
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    let color;
                    if (z > 0) {
                        color = this.TRUNK_COLORS[2];
                    } else if (y > this.trunkBaseY + trunkHeight * 0.6) {
                        color = this.TRUNK_COLORS[0];
                    } else {
                        color = this.TRUNK_COLORS[1];
                    }
                    this.particles.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: color,
                        size: Math.random() * 3.5 + 3, 
                        swaySpeed: 0,
                        swayOffset: 0,
                        isTrunk: true,
                        growth: 1
                    });
                }
            }

            createChristmasTreeCrown(multiplier = 1) {
                const particleCount = Math.floor(3500 * multiplier); 
                const treeHeight = 620 * this.treeScale; 
                const maxRadius = 280 * this.treeScale; 
                const spiralFactor = 10; 
                
                for (let i = 0; i < particleCount; i++) {
                    const p = i / particleCount; 
                    const spiralAngle = i * 2.39996 + p * spiralFactor;
                    const currentHeight = treeHeight * p;
                    const currentRadius = maxRadius * (1 - p);
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.8 + Math.random() * 0.4);
                    const x = Math.cos(spiralAngle) * r;
                    const y = this.crownBaseY - currentHeight; 
                    const z = Math.sin(spiralAngle) * r;

                    if (Math.random() < 0.18) {
                        const color = this.LIGHT_COLORS[Math.floor(Math.random() * this.LIGHT_COLORS.length)];
                        const size = Math.random() * 3.5 + 2.5; 
                        const pulseSpeed = 1.0 + Math.random() * 3.5;
                        const phase = Math.random() * Math.PI * 2;
                        const baseAlpha = 0.5 + Math.random() * 0.6;
                        const sparkleChance = Math.random() < 0.15 ? 0.01 + Math.random()*0.03 : 0;
                        const glow = 8 + Math.random() * 24; 
                        this.lights.push({
                            x: x, y: y, z: z,
                            baseX: x, baseY: y,
                            color: color,
                            size: size,
                            blinkSpeed: pulseSpeed,
                            blinkOffset: phase,
                            baseAlpha: baseAlpha,
                            sparkleChance: sparkleChance,
                            glow: glow,
                            flickerSeed: Math.random() * 1000,
                            growth: 1,
                            spiralAngle: spiralAngle
                        });
                    } else {
                        this.particles.push({
                            x: x, y: y, z: z,
                            baseX: x, baseY: y,
                            color: this.TREE_COLORS[Math.floor(Math.random() * this.TREE_COLORS.length)],
                            size: Math.random() * 1.8 + 0.6, 
                            swaySpeed: Math.random() * 2 + 1,
                            swayOffset: Math.random() * Math.PI * 2,
                            isTrunk: false,
                            growth: 1,
                            spiralAngle: spiralAngle
                        });
                    }
                }
            }

            createTopGifts(multiplier = 1) {
                const treeHeight = 620 * this.treeScale; 
                const maxRadius = 280 * this.treeScale; 
                const topGiftCount = Math.floor(5 * multiplier); 
                const spiralFactor = 12; 
                
                for (let i = 0; i < topGiftCount; i++) {
                    const heightRatio = 0.05 + Math.random() * 0.08;
                    const currentHeight = treeHeight * heightRatio;
                    const y = this.crownBaseY - currentHeight; 
                    
                    const radiusRatio = 0.3 + Math.random() * 0.3; 
                    const currentRadius = maxRadius * (1 - heightRatio) * radiusRatio;
                    
                    const spiralAngle = i * (Math.PI * 2 / topGiftCount) + heightRatio * spiralFactor;
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    const specialColors = [
                        { box: "#FF6B6B", ribbon: "#FFD166" }, 
                        { box: "#4ECDC4", ribbon: "#FFE66D" }, 
                        { box: "#FF8AF0", ribbon: "#7CE6E6" }, 
                        { box: "#FFD166", ribbon: "#FF6B9D" }, 
                        { box: "#A8E6CF", ribbon: "#FFAAA5" }  
                    ];
                    const colorSet = specialColors[i % specialColors.length];
                    
                    const size = (0.45 + Math.random() * 0.45) * this.treeScale * 25; 
                    
                    const rotation = Math.random() * Math.PI * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 0.015; 
                    const swaySpeed = 0.8 + Math.random() * 1.5; 
                    const swayOffset = Math.random() * Math.PI * 2;
                    
                    this.topGifts.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: colorSet.box,
                        ribbonColor: colorSet.ribbon,
                        size: size,
                        rotation: rotation,
                        rotationSpeed: rotationSpeed,
                        swaySpeed: swaySpeed,
                        swayOffset: swayOffset,
                        timeOffset: Math.random() * 1000,
                        glow: 0,
                        sparkleTimer: 0,
                        sparkleIntensity: 0,
                        growth: 1,
                        spiralAngle: spiralAngle,
                        layer: "top", 
                        floatHeight: 5 + Math.random() * 10, 
                        floatSpeed: 1 + Math.random() * 2    
                    });
                }
            }

            createUpperGifts(multiplier = 1) {
                const treeHeight = 620 * this.treeScale; 
                const maxRadius = 280 * this.treeScale; 
                const upperGiftCount = Math.floor(8 * multiplier); 
                const spiralFactor = 8;
                
                for (let i = 0; i < upperGiftCount; i++) {
                    const heightRatio = 0.15 + Math.random() * 0.2; 
                    const currentHeight = treeHeight * heightRatio;
                    const y = this.crownBaseY - currentHeight; 
                    
                    const radiusRatio = 0.6 + Math.random() * 0.3; 
                    const currentRadius = maxRadius * (1 - heightRatio) * radiusRatio;
                    
                    const spiralAngle = i * (Math.PI * 2 / upperGiftCount) + heightRatio * spiralFactor;
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    const colorSet = this.GIFT_COLORS[Math.floor(Math.random() * this.GIFT_COLORS.length)];
                    
                    const size = (0.65 + Math.random() * 0.65) * this.treeScale * 28; 
                    
                    const rotation = Math.random() * Math.PI * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 0.012;
                    const swaySpeed = 0.6 + Math.random() * 1.2;
                    const swayOffset = Math.random() * Math.PI * 2;
                    
                    this.upperGifts.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: colorSet.box,
                        ribbonColor: colorSet.ribbon,
                        size: size,
                        rotation: rotation,
                        rotationSpeed: rotationSpeed,
                        swaySpeed: swaySpeed,
                        swayOffset: swayOffset,
                        timeOffset: Math.random() * 1000,
                        glow: 0,
                        sparkleTimer: 0,
                        sparkleIntensity: 0,
                        growth: 1,
                        spiralAngle: spiralAngle,
                        layer: "upper"
                    });
                }
            }

            createGifts(multiplier = 1) {
                const treeHeight = 620 * this.treeScale; 
                const maxRadius = 280 * this.treeScale; 
                const giftCount = Math.floor(6 * multiplier); 
                const spiralFactor = 8;
                
                for (let i = 0; i < giftCount; i++) {
                    const heightRatio = 0.3 + Math.random() * 0.2; 
                    const currentHeight = treeHeight * heightRatio;
                    const y = this.crownBaseY - currentHeight;
                    
                    const radiusRatio = 0.5 + Math.random() * 0.4; 
                    const currentRadius = maxRadius * (1 - heightRatio) * radiusRatio;
                    
                    const spiralAngle = i * (Math.PI * 2 / giftCount) + heightRatio * spiralFactor;
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    const colorSet = this.GIFT_COLORS[Math.floor(Math.random() * this.GIFT_COLORS.length)];
                    
                    const size = (0.75 + Math.random() * 0.75) * this.treeScale * 30; 
                    
                    const rotation = Math.random() * Math.PI * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 0.01;
                    const swaySpeed = 0.5 + Math.random() * 1.0;
                    const swayOffset = Math.random() * Math.PI * 2;
                    
                    this.gifts.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: colorSet.box,
                        ribbonColor: colorSet.ribbon,
                        size: size,
                        rotation: rotation,
                        rotationSpeed: rotationSpeed,
                        swaySpeed: swaySpeed,
                        swayOffset: swayOffset,
                        timeOffset: Math.random() * 1000,
                        glow: 0,
                        sparkleTimer: 0,
                        sparkleIntensity: 0,
                        growth: 1,
                        spiralAngle: spiralAngle,
                        layer: "middle"
                    });
                }
            }

            createSpiralLights(multiplier = 1) {
                const treeHeight = 620 * this.treeScale; 
                const maxRadius = 280 * this.treeScale; 
                const spiralCount = Math.floor(100 * multiplier); 
                const spiralTurns = 5;
                
                for (let i = 0; i < spiralCount; i++) {
                    const t = i / spiralCount;
                    const currentHeight = treeHeight * t;
                    const y = this.crownBaseY - currentHeight; 
                    
                    const angle = t * Math.PI * 2 * spiralTurns + t * 10;
                    
                    const currentRadius = maxRadius * (1 - t * 0.8) * (0.7 + Math.random() * 0.3);
                    
                    const x = Math.cos(angle) * currentRadius;
                    const z = Math.sin(angle) * currentRadius;
                    
                    const color = this.SPIRAL_LIGHT_COLORS[i % this.SPIRAL_LIGHT_COLORS.length];
                    
                    const size = 1.8 + Math.random() * 1.8; 
                    const pulseSpeed = 2.0 + Math.random() * 2.0;
                    const phase = Math.random() * Math.PI * 2;
                    const baseAlpha = 0.6 + Math.random() * 0.4;
                    const glow = 10 + Math.random() * 20; 
                    
                    this.spiralLights.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: color,
                        size: size,
                        pulseSpeed: pulseSpeed,
                        phase: phase,
                        baseAlpha: baseAlpha,
                        glow: glow,
                        flickerSeed: Math.random() * 1000,
                        trailLength: 3 + Math.floor(Math.random() * 4),
                        trailOffset: 0,
                        growth: 1,
                        spiralAngle: angle
                    });
                }
            }

            createTopStar() {
                const treeHeight = 620 * this.treeScale; 
                const topY = this.crownBaseY - treeHeight;
                
                this.topStar = {
                    x: this.centerX,
                    y: topY - 30, 
                    size: 30 * this.treeScale, 
                    color: '#FFD700',
                    rotation: 0,
                    rotationSpeed: 0.01, // Âõ∫ÂÆöÊòüÊòüËá™ËΩ¨ÈÄüÂ∫¶
                    pulseSpeed: 0.8,
                    glowSize: 48 * this.treeScale, 
                    spikes: 5,
                    innerRadius: 0.4,
                    outerRadius: 1,
                    time: 0,
                    sparkleInterval: 0,
                    growth: 1
                };
            }

            createSnowflakes() {
                const snowflakeCount = this.isMobileDevice ? 300 : 500; // ÊâãÊú∫Á´ØÂáèÂ∞ëÈõ™Ëä±Êï∞Èáè
                for (let i = 0; i < snowflakeCount; i++) { 
                    this.snowflakes.push({
                        x: Math.random() * this.screenWidth,
                        y: Math.random() * this.screenHeight,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 4 + 3, 
                        baseSize: Math.random() * 4 + 3,
                        speedY: Math.random() * 1 + 0.5,
                        swayAmp: Math.random() * 2,
                        swayFreq: Math.random() * 0.02,
                        opacity: Math.random() * 0.6 + 0.3,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.05,
                        type: Math.floor(Math.random() * 3),
                        growth: 0,
                        targetSize: Math.random() * 1.8 + 1,
                        growthSpeed: Math.random() * 0.003 + 0.001
                    });
                }
            }

            noise(seed, t) {
                return (Math.sin(t * 0.7 + seed * 12.345) + Math.sin(t * 1.3 + seed * 4.56)*0.5) * 0.5;
            }

            update() {
                const time = Date.now() / 1000;
                
                // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁ°Æ‰øùËá™Âä®ÊóãËΩ¨ÊåÅÁª≠ËøõË°å
                this.autoRotation += this.rotationSpeed;
                
                if (this.growthProgress < this.maxGrowth) {
                    this.growthProgress += 0.001;
                }
                
                // Êõ¥Êñ∞Á≤íÂ≠ê‰ΩçÁΩÆ
                this.particles.forEach(p => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, p.growth + this.growthProgress);
                    
                    const rotatedX = p.baseX * cos - p.z * sin;
                    const rotatedZ = p.z * cos + p.baseX * sin;
                    
                    p.x = rotatedX * growthFactor + this.centerX;
                    
                    if (!p.isTrunk) {
                        const spiralSway = Math.sin(time * 0.5 + p.spiralAngle) * 2;
                        p.y = p.baseY + Math.sin(time * p.swaySpeed + p.swayOffset) * 2 * growthFactor + spiralSway;
                    } else {
                        p.y = p.baseY * growthFactor;
                    }
                });

                // Êõ¥Êñ∞ÁÅØÂÖâ
                this.lights.forEach(l => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, l.growth + this.growthProgress);
                    
                    const rotatedX = l.baseX * cos - l.z * sin;
                    const rotatedZ = l.z * cos + l.baseX * sin;

                    l.x = rotatedX * growthFactor + this.centerX;
                    l.y = l.baseY * growthFactor;

                    const sinPart = (Math.sin(time * l.blinkSpeed + l.blinkOffset) + 1) / 2;
                    const noisePart = (this.noise(l.flickerSeed, time) + 1) / 2 * 0.25;
                    l.alpha = Math.min(1, l.baseAlpha * (0.6 + 0.8 * sinPart) + noisePart);

                    l.x += Math.sin(time * 2 + l.flickerSeed + l.spiralAngle) * 0.8 * growthFactor;
                    l.y += Math.cos(time * 1.5 + l.flickerSeed + l.spiralAngle) * 0.6 * growthFactor;

                    if (l.sparkleChance > 0 && Math.random() < l.sparkleChance) {
                        l._sparkle = 0.9 + Math.random() * 0.5;
                        l._sparkleTimer = 6 + Math.floor(Math.random()*8);
                    }
                    if (l._sparkleTimer > 0) {
                        l._sparkleTimer--;
                        l.alpha = Math.min(1.4, l.alpha + (l._sparkle || 0));
                        if (l._sparkleTimer === 0) { l._sparkle = 0; }
                    }
                });

                // Êõ¥Êñ∞È°∂ÈÉ®Á§ºÁâ©
                this.topGifts.forEach(gift => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, gift.growth + this.growthProgress);
                    
                    const rotatedX = gift.baseX * cos - gift.z * sin;
                    const rotatedZ = gift.z * cos + gift.baseX * sin;

                    gift.x = rotatedX * growthFactor + this.centerX;
                    
                    const floatOffset = Math.sin(time * gift.floatSpeed + gift.timeOffset) * gift.floatHeight;
                    const spiralSway = Math.sin(time * 0.3 + gift.spiralAngle) * 4;
                    gift.y = gift.baseY * growthFactor + Math.sin(time * gift.swaySpeed + gift.swayOffset) * 3 + spiralSway + floatOffset;
                    
                    gift.rotation += gift.rotationSpeed + 0.004;
                    
                    gift.glow = 0.5 + 0.4 * Math.sin(time * 2.0 + gift.timeOffset);
                    
                    if (Math.random() < 0.015) {
                        gift.sparkleTimer = 20;
                        gift.sparkleIntensity = 0.6 + Math.random() * 0.6;
                    }
                    
                    if (gift.sparkleTimer > 0) {
                        gift.sparkleTimer--;
                    }
                });

                // Êõ¥Êñ∞‰∏äÂ±ÇÁ§ºÁâ©
                this.upperGifts.forEach(gift => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, gift.growth + this.growthProgress);
                    
                    const rotatedX = gift.baseX * cos - gift.z * sin;
                    const rotatedZ = gift.z * cos + gift.baseX * sin;

                    gift.x = rotatedX * growthFactor + this.centerX;
                    
                    const spiralSway = Math.sin(time * 0.25 + gift.spiralAngle) * 3;
                    gift.y = gift.baseY * growthFactor + Math.sin(time * gift.swaySpeed + gift.swayOffset) * 2.5 + spiralSway;
                    
                    gift.rotation += gift.rotationSpeed + 0.003;
                    
                    gift.glow = 0.4 + 0.3 * Math.sin(time * 1.8 + gift.timeOffset);
                    
                    if (Math.random() < 0.012) {
                        gift.sparkleTimer = 18;
                        gift.sparkleIntensity = 0.5 + Math.random() * 0.5;
                    }
                    
                    if (gift.sparkleTimer > 0) {
                        gift.sparkleTimer--;
                    }
                });

                // Êõ¥Êñ∞‰∏≠Â±ÇÁ§ºÁâ©
                this.gifts.forEach(gift => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, gift.growth + this.growthProgress);
                    
                    const rotatedX = gift.baseX * cos - gift.z * sin;
                    const rotatedZ = gift.z * cos + gift.baseX * sin;

                    gift.x = rotatedX * growthFactor + this.centerX;
                    
                    const spiralSway = Math.sin(time * 0.2 + gift.spiralAngle) * 2;
                    gift.y = gift.baseY * growthFactor + Math.sin(time * gift.swaySpeed + gift.swayOffset) * 2 + spiralSway;
                    
                    gift.rotation += gift.rotationSpeed + 0.002;
                    
                    gift.glow = 0.3 + 0.2 * Math.sin(time * 1.5 + gift.timeOffset);
                    
                    if (Math.random() < 0.01) {
                        gift.sparkleTimer = 15;
                        gift.sparkleIntensity = 0.4 + Math.random() * 0.4;
                    }
                    
                    if (gift.sparkleTimer > 0) {
                        gift.sparkleTimer--;
                    }
                });

                // Êõ¥Êñ∞Ëû∫ÊóãÁÅØÂÖâ
                this.spiralLights.forEach(light => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, light.growth + this.growthProgress);
                    
                    const rotatedX = light.baseX * cos - light.z * sin;
                    const rotatedZ = light.z * cos + light.baseX * sin;

                    light.x = rotatedX * growthFactor + this.centerX;
                    light.y = light.baseY * growthFactor;
                    
                    const sinPart = (Math.sin(time * light.pulseSpeed + light.phase + light.spiralAngle) + 1) / 2;
                    const noisePart = (this.noise(light.flickerSeed, time) + 1) / 2 * 0.3;
                    light.alpha = Math.min(1, light.baseAlpha * (0.7 + 0.6 * sinPart) + noisePart);
                    
                    light.trailOffset = (light.trailOffset + 1) % (light.trailLength + 1);
                });

                // Êõ¥Êñ∞Èõ™Ëä±
                this.snowflakes.forEach(s => {
                    if (s.growth < s.targetSize) {
                        s.growth += s.growthSpeed;
                    } else {
                        s.growth = 0;
                        s.targetSize = Math.random() * 1.8 + 1;
                    }
                    
                    const currentSize = s.baseSize * (1 + s.growth);
                    
                    s.y += s.speedY * s.z; 
                    s.x += Math.sin(time + s.y * 0.01) * s.swayAmp;
                    s.rotation += s.rotationSpeed * (1 + s.growth * 0.5);
                    
                    s.size = currentSize;
                    
                    if (s.y > this.screenHeight) {
                        s.y = -10;
                        s.x = Math.random() * this.screenWidth;
                        s.size = s.baseSize = Math.random() * 4 + 3; 
                        s.growth = 0;
                        s.targetSize = Math.random() * 1.8 + 1;
                    }
                    if (s.x > this.screenWidth) s.x = 0;
                    if (s.x < 0) s.x = this.screenWidth;
                });

                // Êõ¥Êñ∞È°∂ÈÉ®ÊòüÊòü
                if (this.topStar) {
                    this.topStar.time = time;
                    this.topStar.rotation += this.topStar.rotationSpeed;
                    
                    this.topStar.size = 30 * this.treeScale + Math.sin(time * this.topStar.pulseSpeed) * 3.5; 
                    this.topStar.glowSize = 48 * this.treeScale + Math.sin(time * 1.5) * 8; 
                    
                    this.topStar.sparkleInterval++;
                    if (this.topStar.sparkleInterval > 30 + Math.random() * 50) {
                        this.topStar.sparkleInterval = 0;
                        this.topStar._sparkle = 2.0 + Math.random() * 1.5;
                        this.topStar._sparkleTimer = 15;
                    }
                }
            }

            drawLightGlow(x, y, size, color, alpha, glow) {
                const ctx = this.ctx;
                const g = ctx.createRadialGradient(x, y, 0, x, y, glow);
                g.addColorStop(0, `rgba(255,255,255,${Math.min(1, alpha*1.2)})`);
                g.addColorStop(0.1, this.hexToRgba(color, alpha));
                g.addColorStop(0.6, this.hexToRgba(color, alpha*0.28));
                g.addColorStop(1, this.hexToRgba(color, 0));
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, glow, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI*2);
                ctx.fillStyle = this.hexToRgba(color, Math.min(1, alpha*1.1));
                ctx.fill();
            }

            drawSpiralLight(x, y, size, color, alpha, glow, trailLength, trailOffset) {
                const ctx = this.ctx;
                
                // ÊâãÊú∫Á´ØÂáèÂ∞ëÊãñÂ∞æÊïàÊûú
                const maxTrail = this.isMobileDevice ? Math.min(2, trailLength) : trailLength;
                
                for (let i = 0; i < maxTrail; i++) {
                    if (i === trailOffset) continue;
                    
                    const trailAlpha = alpha * (1 - i / trailLength) * 0.3;
                    const trailGlow = glow * (1 - i / trailLength * 0.7);
                    
                    const g = ctx.createRadialGradient(x, y, 0, x, y, trailGlow);
                    g.addColorStop(0, this.hexToRgba(color, trailAlpha * 0.5));
                    g.addColorStop(0.3, this.hexToRgba(color, trailAlpha * 0.3));
                    g.addColorStop(1, this.hexToRgba(color, 0));
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, trailGlow, 0, Math.PI*2);
                    ctx.fill();
                }
                
                this.drawLightGlow(x, y, size, color, alpha, glow);
            }

            drawGift(x, y, size, rotation, boxColor, ribbonColor, glow = 0, sparkle = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                if (glow > 0) {
                    ctx.globalCompositeOperation = 'lighter';
                    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
                    glowGradient.addColorStop(0, this.hexToRgba(boxColor, glow * 0.3));
                    glowGradient.addColorStop(1, this.hexToRgba(boxColor, 0));
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                ctx.fillStyle = boxColor;
                ctx.fillRect(-size/2, -size/2, size, size);
                
                ctx.fillStyle = this.hexToRgba('#FFFFFF', 0.15);
                ctx.fillRect(-size/2, -size/2, size * 0.8, size * 0.12);
                ctx.fillRect(-size/2, -size/2, size * 0.12, size * 0.8);
                
                ctx.fillStyle = ribbonColor;
                ctx.fillRect(-size/2, -size/6, size, size/3);
                ctx.fillRect(-size/6, -size/2, size/3, size);
                
                ctx.beginPath();
                ctx.arc(0, 0, size/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.hexToRgba('#FFFFFF', 0.3);
                ctx.beginPath();
                ctx.arc(-size/8, -size/8, size/8, 0, Math.PI * 2);
                ctx.arc(size/8, -size/8, size/8, 0, Math.PI * 2);
                ctx.arc(-size/8, size/8, size/8, 0, Math.PI * 2);
                ctx.arc(size/8, size/8, size/8, 0, Math.PI * 2);
                ctx.fill();
                
                if (sparkle > 0) {
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = `rgba(255, 255, 255, ${sparkle})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                ctx.restore();
            }

            drawStar(x, y, spikes, outerRadius, innerRadius, color, rotation = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                const angleStep = (Math.PI * 2) / spikes;
                const halfAngleStep = angleStep / 2;
                
                ctx.beginPath();
                
                for (let i = 0; i < spikes; i++) {
                    const outerAngle = i * angleStep - Math.PI / 2;
                    const outerX = Math.cos(outerAngle) * outerRadius;
                    const outerY = Math.sin(outerAngle) * outerRadius;
                    
                    const innerAngle = outerAngle + halfAngleStep;
                    const innerX = Math.cos(innerAngle) * innerRadius;
                    const innerY = Math.sin(innerAngle) * innerRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    
                    ctx.lineTo(innerX, innerY);
                }
                
                const firstOuterX = Math.cos(-Math.PI / 2) * outerRadius;
                const firstOuterY = Math.sin(-Math.PI / 2) * outerRadius;
                ctx.lineTo(firstOuterX, firstOuterY);
                
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            drawHexagonSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    ctx.lineWidth = size * 0.15;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(size * 0.4, size * 0.5);
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.4, size * 0.5);
                    
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(size * 0.3, size * 0.6);
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(-size * 0.3, size * 0.6);
                    
                    ctx.lineWidth = size * 0.1;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            drawStarSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    
                    ctx.moveTo(size * 0.2, size * 0.4);
                    ctx.lineTo(-size * 0.2, size * 0.4);
                    ctx.moveTo(size * 0.15, size * 0.7);
                    ctx.lineTo(-size * 0.15, size * 0.7);
                    
                    ctx.lineWidth = size * 0.08;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
                    ctx.stroke();
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                ctx.restore();
            }

            drawFlowerSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(size * 0.3, size * 0.2, 0, size);
                    ctx.quadraticCurveTo(-size * 0.3, size * 0.2, 0, 0);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.5);
                    ctx.lineTo(0, size * 0.8);
                    ctx.lineWidth = size * 0.05;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            hexToRgba(hex, alpha=1) {
                const h = hex.replace('#','');
                const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r},${g},${b},${alpha})`;
            }

            drawSparkle(x, y, size, intensity) {
                const ctx = this.ctx;
                const len = size * (1 + intensity * 0.6);
                ctx.save();
                ctx.globalAlpha = Math.min(1, intensity);
                ctx.lineWidth = Math.max(1, size * 0.12);
                ctx.lineCap = 'round';
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.moveTo(x - len, y);
                ctx.lineTo(x + len, y);
                ctx.moveTo(x, y - len);
                ctx.lineTo(x, y + len);
                ctx.stroke();
                ctx.restore();
            }

            draw() {
                // Êõ¥Êñ∞Âä®ÁîªÁä∂ÊÄÅ
                this.update();
                
                // Ê∏ÖÈô§ÁîªÂ∏É
                this.ctx.fillStyle = "#0a0a2a";
                this.ctx.fillRect(0, 0, this.screenWidth, this.screenHeight);

                this.ctx.globalCompositeOperation = 'lighter';

                // ÁªòÂà∂Ê†ëÂπ≤Á≤íÂ≠ê
                this.particles.forEach(p => {
                    this.ctx.beginPath();
                    const sizeMultiplier = p.isTrunk ? 1.5 : 1;
                    const growthFactor = Math.min(1, p.growth + this.growthProgress);
                    this.ctx.arc(p.x, p.y, p.size * this.treeScale * sizeMultiplier * growthFactor, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.isTrunk ? 0.9 : 0.6;
                    this.ctx.fill();
                });

                // ÁªòÂà∂Ëû∫ÊóãÁÅØ
                this.spiralLights.forEach(light => {
                    const growthFactor = Math.min(1, light.growth + this.growthProgress);
                    this.drawSpiralLight(
                        light.x,
                        light.y,
                        light.size * this.treeScale * growthFactor,
                        light.color,
                        light.alpha,
                        light.glow * this.treeScale * growthFactor,
                        light.trailLength,
                        light.trailOffset
                    );
                });

                // ÁªòÂà∂Á§ºÁâ©
                this.gifts.forEach(gift => {
                    const sparkleIntensity = gift.sparkleTimer > 0 ? 
                        (gift.sparkleIntensity * (gift.sparkleTimer / 15)) : 0;
                    
                    this.drawGift(
                        gift.x, 
                        gift.y, 
                        gift.size * Math.min(1, gift.growth + this.growthProgress), 
                        gift.rotation, 
                        gift.color, 
                        gift.ribbonColor, 
                        gift.glow,
                        sparkleIntensity
                    );
                });

                this.upperGifts.forEach(gift => {
                    const sparkleIntensity = gift.sparkleTimer > 0 ? 
                        (gift.sparkleIntensity * (gift.sparkleTimer / 18)) : 0;
                    
                    this.drawGift(
                        gift.x, 
                        gift.y, 
                        gift.size * Math.min(1, gift.growth + this.growthProgress), 
                        gift.rotation, 
                        gift.color, 
                        gift.ribbonColor, 
                        gift.glow,
                        sparkleIntensity
                    );
                });

                this.topGifts.forEach(gift => {
                    const sparkleIntensity = gift.sparkleTimer > 0 ? 
                        (gift.sparkleIntensity * (gift.sparkleTimer / 20)) : 0;
                    
                    this.drawGift(
                        gift.x, 
                        gift.y, 
                        gift.size * Math.min(1, gift.growth + this.growthProgress), 
                        gift.rotation, 
                        gift.color, 
                        gift.ribbonColor, 
                        gift.glow,
                        sparkleIntensity
                    );
                });

                // ÁªòÂà∂ÁÅØ
                this.lights.forEach(l => {
                    const growthFactor = Math.min(1, l.growth + this.growthProgress);
                    let depthBoost = l.z > 0 ? 1.1 : 1.0;
                    this.drawLightGlow(l.x, l.y, l.size * this.treeScale * growthFactor, l.color, l.alpha * depthBoost, l.glow * this.treeScale * growthFactor);
                    
                    // ÊâãÊú∫Á´ØÂáèÂ∞ëÈó™ÂÖâÊïàÊûú
                    if (!this.isMobileDevice && Math.random() < 0.02) {
                        this.drawSparkle(
                            l.x + (Math.random()-0.5)*4,
                            l.y + (Math.random()-0.5)*4,
                            Math.max(2, l.size*2) * growthFactor,
                            0.9 + Math.random()*0.6
                        );
                    }
                });

                // ÁªòÂà∂È°∂ÈÉ®ÊòüÊòü
                if (this.topStar) {
                    const star = this.topStar;
                    const time = Date.now() / 1000;
                    const growthFactor = Math.min(1, star.growth + this.growthProgress);
                    
                    this.ctx.save();
                    
                    const glowGradient = this.ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.glowSize * growthFactor
                    );
                    
                    glowGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    glowGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.6)');
                    glowGradient.addColorStop(0.7, 'rgba(255, 140, 0, 0.3)');
                    glowGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    
                    this.ctx.globalCompositeOperation = 'lighter';
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.glowSize * growthFactor, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const innerGlowGradient = this.ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.glowSize * 0.6 * growthFactor
                    );
                    
                    innerGlowGradient.addColorStop(0, 'rgba(255, 255, 230, 0.9)');
                    innerGlowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.6)');
                    innerGlowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    this.ctx.fillStyle = innerGlowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.glowSize * 0.6 * growthFactor, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.drawStar(
                        star.x, 
                        star.y, 
                        star.spikes, 
                        star.size * growthFactor, 
                        star.size * star.innerRadius * growthFactor, 
                        '#FFD700', 
                        star.rotation
                    );
                    
                    this.drawStar(
                        star.x, 
                        star.y, 
                        star.spikes, 
                        star.size * 0.7 * growthFactor,
                        star.size * 0.7 * star.innerRadius * growthFactor, 
                        '#FFFACD', 
                        star.rotation + 0.1
                    );
                    
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size * 0.3 * growthFactor, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.ctx.fill();
                    
                    if (Math.random() < 0.15) {
                        this.drawSparkle(
                            star.x + (Math.random()-0.5)*15,
                            star.y + (Math.random()-0.5)*15,
                            3 + Math.random()*4,
                            0.8 + Math.random()*0.6
                        );
                    }
                    
                    if (star._sparkleTimer > 0) {
                        star._sparkleTimer--;
                        const sparkleAlpha = star._sparkleTimer / 15;
                        this.drawSparkle(star.x, star.y, 25, sparkleAlpha * (star._sparkle || 1));
                    }
                    
                    this.ctx.restore();
                }

                this.ctx.globalCompositeOperation = 'source-over';
                
                // ÁªòÂà∂Èõ™Ëä±
                this.snowflakes.forEach(s => {
                    if (this.topStar) {
                        const dx = s.x - this.topStar.x;
                        const dy = s.y - this.topStar.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 60) {
                            return;
                        }
                    }
                    
                    // ÊÄßËÉΩ‰ºòÂåñÔºöËøúÂ§ÑÈõ™Ëä±ÁÆÄÂåñÁªòÂà∂
                    if (this.isMobileDevice && s.z < 1.2) {
                        this.ctx.beginPath();
                        this.ctx.arc(s.x, s.y, s.size * 0.5, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${s.opacity * 0.7})`;
                        this.ctx.fill();
                    } else {
                        switch(s.type) {
                            case 0:
                                this.drawHexagonSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                                break;
                            case 1:
                                this.drawStarSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                                break;
                            case 2:
                                this.drawFlowerSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                                break;
                        }
                    }
                });

                this.ctx.globalAlpha = 1.0;
                
                // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊåÅÁª≠ËØ∑Ê±ÇÂä®ÁîªÂ∏ß
                this.animationFrameId = requestAnimationFrame(() => this.draw());
            }

            startAnimation() {
                // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁ°Æ‰øùÂä®ÁîªÂæ™ÁéØÂºÄÂßã
                this.animationFrameId = requestAnimationFrame(() => this.draw());
            }
        }

        // È°µÈù¢Âä†ËΩΩÂÆåÊàê
        window.addEventListener('load', () => {
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden';
            
            // Èò≤Ê≠¢È°µÈù¢ÊªöÂä®
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 0);
            
            // ÂàùÂßãÂåñÂä®Áîª
            setTimeout(() => {
                const animation = new ChristmasAnimation();
                window.christmasAnimation = animation;
                
                // È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÊó∂ÈáçÊñ∞Ë∞ÉÊï¥
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        setTimeout(() => {
                            animation.handleResize();
                        }, 100);
                    }
                });
            }, 100);
        });

        // Ê®™Á´ñÂ±èÂàáÊç¢Â§ÑÁêÜ
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                window.scrollTo(0, 0);
                if (window.christmasAnimation) {
                    window.christmasAnimation.handleResize();
                }
            }, 300);
        });

        // Èò≤Ê≠¢ÂèåÂáªÁº©Êîæ
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>