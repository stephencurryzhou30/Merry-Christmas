<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas from Zhou</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: radial-gradient(circle at center, #1a1a3a 0%, #03030c 100%);
            overflow: hidden;
            font-family: 'Great Vibes', cursive;
        }
        
        #canvasContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas { display: block; }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #4ECDC4;
            font-size: 20px;
            z-index: 10;
            transition: opacity 0.5s;
            font-family: 'Arial', sans-serif;
        }

        #textContainer {
            position: absolute;
            bottom: 4%; 
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
            mix-blend-mode: screen;
        }

        #mainText {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(48px, 6vw, 72px);
            font-weight: 400;
            letter-spacing: 3px;
            color: #FFD700;
            text-shadow: 
                0 0 10px rgba(255, 215, 0, 0.8),
                0 0 20px rgba(255, 215, 0, 0.6),
                0 0 30px rgba(255, 215, 0, 0.4),
                0 0 40px rgba(255, 107, 157, 0.3),
                0 5px 15px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateY(30px);
            animation: textFloatIn 2s ease-out forwards 1s;
            position: relative;
            display: inline-block;
        }

        @keyframes textFloatIn {
            0% { opacity: 0; transform: translateY(30px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes textGlow {
            0%, 100% { 
                text-shadow: 
                    0 0 10px rgba(255, 215, 0, 0.8),
                    0 0 20px rgba(255, 215, 0, 0.6),
                    0 0 30px rgba(255, 215, 0, 0.4),
                    0 0 40px rgba(255, 107, 157, 0.3),
                    0 5px 15px rgba(0, 0, 0, 0.5);
            }
            50% { 
                text-shadow: 
                    0 0 15px rgba(255, 215, 0, 1),
                    0 0 25px rgba(255, 215, 0, 0.8),
                    0 0 35px rgba(255, 215, 0, 0.6),
                    0 0 45px rgba(255, 107, 157, 0.5),
                    0 5px 15px rgba(0, 0, 0, 0.5);
            }
        }

        #mainText {
            animation: 
                textFloatIn 2s ease-out forwards 1s,
                textGlow 3s ease-in-out infinite 3s;
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="christmasCanvas"></canvas>
        <div id="loading"></div>
        <div id="textContainer">
            <div id="mainText">Merry Christmas</div>
        </div>
    </div>

    <script>
        class ChristmasAnimation {
            constructor() {
                this.canvas = document.getElementById('christmasCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                
                this.mouse = { x: 0, y: 0 };
                this.targetMouse = { x: 0, y: 0 };
                
                this.setupCanvas();
                this.initColors();
                this.addEventListeners();
                this.createScene();
                this.startAnimation();
            }

            setupCanvas() {
                this.dpr = window.devicePixelRatio || 1;
                this.screenWidth = window.innerWidth;
                this.screenHeight = window.innerHeight;
                
                this.canvas.width = this.screenWidth * this.dpr;
                this.canvas.height = this.screenHeight * this.dpr;
                this.canvas.style.width = this.screenWidth + 'px';
                this.canvas.style.height = this.screenHeight + 'px';
                
                this.ctx.scale(this.dpr, this.dpr);
                
                this.centerX = this.screenWidth / 2;
                this.centerY = this.screenHeight / 2;
                
                this.treeBaseY = this.screenHeight * 0.7; 
                
                this.treeScale = Math.min(this.screenWidth, this.screenHeight) / 1000;
                
                setTimeout(() => {
                    this.loading.style.opacity = 0;
                    setTimeout(() => this.loading.style.display = 'none', 500);
                }, 300);
            }

            addEventListeners() {
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.createScene(); 
                });

                window.addEventListener('mousemove', (e) => {
                    this.targetMouse.x = (e.clientX - this.centerX) / this.centerX;
                    this.targetMouse.y = (e.clientY - this.centerY) / this.centerY;
                });
            }

            initColors() {
                this.TREE_COLORS = ["#2E8B57", "#3CB371", "#20B2AA", "#66CDAA", "#00FA9A"];
                this.LIGHT_COLORS = ["#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", "#FFA552", "#93FF9B"];
                this.TRUNK_COLORS = ["#5C3317", "#6F4E37", "#8B4513"]; 
            }

            createScene() {
                this.particles = []; 
                this.lights = [];    
                this.snowflakes = [];
                this.stars = [];     
                this.topStar = null;

                this.createChristmasTree();
                this.createSnowflakes();
                this.createTopStar();
            }

            createChristmasTree() {
                const trunkHeight = 150 * this.treeScale;
                const trunkRadius = 40 * this.treeScale;
                const trunkCount = 800;
                for (let i = 0; i < trunkCount; i++) {
                    const p = i / trunkCount;
                    const y = this.treeBaseY + p * trunkHeight;
                    const angle = i * 2.39996;
                    const currentRadius = trunkRadius * (1 - 0.2 * p);
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.5 + Math.random() * 0.5);
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    let color;
                    if (z > 0) {
                        color = this.TRUNK_COLORS[2];
                    } else if (y > this.treeBaseY + trunkHeight * 0.6) {
                        color = this.TRUNK_COLORS[0];
                    } else {
                        color = this.TRUNK_COLORS[1];
                    }
                    this.particles.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: color,
                        size: Math.random() * 3 + 3,
                        swaySpeed: 0,
                        swayOffset: 0,
                        isTrunk: true
                    });
                }

                const particleCount = 2000; 
                const treeHeight = 550 * this.treeScale; 
                const maxRadius = 240 * this.treeScale;
                
                for (let i = 0; i < particleCount; i++) {
                    const p = i / particleCount; 
                    const angle = i * 2.39996; 
                    
                    const currentHeight = treeHeight * p;
                    const currentRadius = maxRadius * (1 - p);
                    
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.8 + Math.random() * 0.4);
                    
                    const x = Math.cos(angle) * r;
                    const y = this.treeBaseY - currentHeight; 
                    const z = Math.sin(angle) * r;

                    if (Math.random() < 0.18) {
                        const color = this.LIGHT_COLORS[Math.floor(Math.random() * this.LIGHT_COLORS.length)];
                        const size = Math.random() * 3 + 2;
                        const pulseSpeed = 1.0 + Math.random() * 3.5;
                        const phase = Math.random() * Math.PI * 2;
                        const baseAlpha = 0.5 + Math.random() * 0.6;
                        const sparkleChance = Math.random() < 0.15 ? 0.01 + Math.random()*0.03 : 0;
                        const glow = 8 + Math.random() * 24;
                        this.lights.push({
                            x: x, y: y, z: z,
                            baseX: x, baseY: y,
                            color: color,
                            size: size,
                            blinkSpeed: pulseSpeed,
                            blinkOffset: phase,
                            baseAlpha: baseAlpha,
                            sparkleChance: sparkleChance,
                            glow: glow,
                            flickerSeed: Math.random() * 1000
                        });
                    } else {
                        this.particles.push({
                            x: x, y: y, z: z,
                            baseX: x, baseY: y,
                            color: this.TREE_COLORS[Math.floor(Math.random() * this.TREE_COLORS.length)],
                            size: Math.random() * 1.5 + 0.5,
                            swaySpeed: Math.random() * 2 + 1,
                            swayOffset: Math.random() * Math.PI * 2,
                            isTrunk: false
                        });
                    }
                }
            }

            createTopStar() {
                const treeHeight = 550 * this.treeScale;
                const topY = this.treeBaseY - treeHeight; 
                
                // 修正星星参数
                this.topStar = {
                    x: this.centerX,
                    y: topY - 15, // 稍微向上调整
                    size: 24 * this.treeScale, // 调整大小
                    color: '#FFD700',
                    rotation: 0,
                    pulseSpeed: 0.8,
                    glowSize: 40 * this.treeScale,
                    spikes: 5,
                    innerRadius: 0.4, // 调整内半径比例，让星星更明显
                    outerRadius: 1,
                    time: 0,
                    sparkleInterval: 0
                };
            }

            createSnowflakes() {
                for (let i = 0; i < 300; i++) {
                    this.snowflakes.push({
                        x: Math.random() * this.screenWidth,
                        y: Math.random() * this.screenHeight,
                        z: Math.random() * 2 + 0.5, 
                        size: Math.random() * 3 + 2,
                        speedY: Math.random() * 1 + 0.5,
                        swayAmp: Math.random() * 2,
                        swayFreq: Math.random() * 0.02,
                        opacity: Math.random() * 0.6 + 0.3,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.03,
                        type: Math.floor(Math.random() * 3)
                    });
                }
            }

            noise(seed, t) {
                return (Math.sin(t * 0.7 + seed * 12.345) + Math.sin(t * 1.3 + seed * 4.56)*0.5) * 0.5;
            }

            update() {
                const time = Date.now() / 1000;
                
                this.mouse.x += (this.targetMouse.x - this.mouse.x) * 0.05;
                this.mouse.y += (this.targetMouse.y - this.mouse.y) * 0.05;

                this.particles.forEach(p => {
                    const rotation = this.mouse.x * 0.3;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const rotatedX = p.baseX * cos - p.z * sin;
                    const rotatedZ = p.z * cos + p.baseX * sin;
                    
                    p.x = rotatedX + this.centerX;
                    
                    if (!p.isTrunk) {
                        p.y = p.baseY + Math.sin(time * p.swaySpeed + p.swayOffset) * 2; 
                    } else {
                        p.y = p.baseY;
                    }
                });

                this.lights.forEach(l => {
                    const rotation = this.mouse.x * 0.3;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const rotatedX = l.baseX * cos - l.z * sin;
                    const rotatedZ = l.z * cos + l.baseX * sin;

                    l.x = rotatedX + this.centerX;
                    l.y = l.baseY;

                    const sinPart = (Math.sin(time * l.blinkSpeed + l.blinkOffset) + 1) / 2;
                    const noisePart = (this.noise(l.flickerSeed, time) + 1) / 2 * 0.25;
                    l.alpha = Math.min(1, l.baseAlpha * (0.6 + 0.8 * sinPart) + noisePart);

                    l.x += Math.sin(time * 2 + l.flickerSeed) * 0.6;
                    l.y += Math.cos(time * 1.5 + l.flickerSeed) * 0.4;

                    if (l.sparkleChance > 0 && Math.random() < l.sparkleChance) {
                        l._sparkle = 0.9 + Math.random() * 0.5;
                        l._sparkleTimer = 6 + Math.floor(Math.random()*8);
                    }
                    if (l._sparkleTimer > 0) {
                        l._sparkleTimer--;
                        l.alpha = Math.min(1.4, l.alpha + (l._sparkle || 0));
                        if (l._sparkleTimer === 0) { l._sparkle = 0; }
                    }
                });

                this.snowflakes.forEach(s => {
                    s.y += s.speedY * s.z; 
                    s.x += Math.sin(time + s.y * 0.01) * s.swayAmp - this.mouse.x * 2; 
                    s.rotation += s.rotationSpeed;
                    
                    if (s.y > this.screenHeight) {
                        s.y = -10;
                        s.x = Math.random() * this.screenWidth;
                    }
                    if (s.x > this.screenWidth) s.x = 0;
                    if (s.x < 0) s.x = this.screenWidth;
                });

                // 更新顶部星星
                if (this.topStar) {
                    this.topStar.time = time;
                    this.topStar.rotation += 0.003;
                    
                    this.topStar.size = 24 * this.treeScale + Math.sin(time * this.topStar.pulseSpeed) * 3;
                    this.topStar.glowSize = 40 * this.treeScale + Math.sin(time * 1.5) * 8;
                    
                    this.topStar.sparkleInterval++;
                    if (this.topStar.sparkleInterval > 30 + Math.random() * 50) {
                        this.topStar.sparkleInterval = 0;
                        this.topStar._sparkle = 2.0 + Math.random() * 1.5;
                        this.topStar._sparkleTimer = 15;
                    }
                }
            }

            drawLightGlow(x, y, size, color, alpha, glow) {
                const ctx = this.ctx;
                const g = ctx.createRadialGradient(x, y, 0, x, y, glow);
                g.addColorStop(0, `rgba(255,255,255,${Math.min(1, alpha*1.2)})`);
                g.addColorStop(0.1, this.hexToRgba(color, alpha));
                g.addColorStop(0.6, this.hexToRgba(color, alpha*0.28));
                g.addColorStop(1, this.hexToRgba(color, 0));
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, glow, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI*2);
                ctx.fillStyle = this.hexToRgba(color, Math.min(1, alpha*1.1));
                ctx.fill();
            }

            // 修复的星星绘制函数
            drawStar(x, y, spikes, outerRadius, innerRadius, color, rotation = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                // 确保星星绘制完整
                const angleStep = (Math.PI * 2) / spikes;
                const halfAngleStep = angleStep / 2;
                
                ctx.beginPath();
                
                // 从顶部开始
                for (let i = 0; i < spikes; i++) {
                    // 外角
                    const outerAngle = i * angleStep - Math.PI / 2;
                    const outerX = Math.cos(outerAngle) * outerRadius;
                    const outerY = Math.sin(outerAngle) * outerRadius;
                    
                    // 内角
                    const innerAngle = outerAngle + halfAngleStep;
                    const innerX = Math.cos(innerAngle) * innerRadius;
                    const innerY = Math.sin(innerAngle) * innerRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    
                    ctx.lineTo(innerX, innerY);
                }
                
                // 回到起点
                const firstOuterX = Math.cos(-Math.PI / 2) * outerRadius;
                const firstOuterY = Math.sin(-Math.PI / 2) * outerRadius;
                ctx.lineTo(firstOuterX, firstOuterY);
                
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            // 绘制六边形雪花
            drawHexagonSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    ctx.lineWidth = size * 0.15;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(size * 0.4, size * 0.5);
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.4, size * 0.5);
                    
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(size * 0.3, size * 0.6);
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(-size * 0.3, size * 0.6);
                    
                    ctx.lineWidth = size * 0.1;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            // 绘制星形雪花
            drawStarSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    
                    ctx.moveTo(size * 0.2, size * 0.4);
                    ctx.lineTo(-size * 0.2, size * 0.4);
                    ctx.moveTo(size * 0.15, size * 0.7);
                    ctx.lineTo(-size * 0.15, size * 0.7);
                    
                    ctx.lineWidth = size * 0.08;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
                    ctx.stroke();
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                ctx.restore();
            }

            // 绘制花形雪花
            drawFlowerSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(size * 0.3, size * 0.2, 0, size);
                    ctx.quadraticCurveTo(-size * 0.3, size * 0.2, 0, 0);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.5);
                    ctx.lineTo(0, size * 0.8);
                    ctx.lineWidth = size * 0.05;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            hexToRgba(hex, alpha=1) {
                const h = hex.replace('#','');
                const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r},${g},${b},${alpha})`;
            }

            drawSparkle(x, y, size, intensity) {
                const ctx = this.ctx;
                const len = size * (1 + intensity * 0.6);
                ctx.save();
                ctx.globalAlpha = Math.min(1, intensity);
                ctx.lineWidth = Math.max(1, size * 0.12);
                ctx.lineCap = 'round';
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.moveTo(x - len, y);
                ctx.lineTo(x + len, y);
                ctx.moveTo(x, y - len);
                ctx.lineTo(x, y + len);
                ctx.stroke();
                ctx.restore();
            }

            draw() {
                this.ctx.fillStyle = "#0a0a2a";
                this.ctx.fillRect(0, 0, this.screenWidth, this.screenHeight);

                this.ctx.globalCompositeOperation = 'lighter';

                // 绘制树叶与树干
                this.particles.forEach(p => {
                    this.ctx.beginPath();
                    const sizeMultiplier = p.isTrunk ? 1.5 : 1;
                    this.ctx.arc(p.x, p.y, p.size * this.treeScale * sizeMultiplier, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.isTrunk ? 0.9 : 0.6;
                    this.ctx.fill();
                });

                // 绘制灯珠
                this.lights.forEach(l => {
                    let depthBoost = l.z > 0 ? 1.1 : 1.0;
                    this.drawLightGlow(l.x, l.y, l.size * this.treeScale, l.color, l.alpha * depthBoost, l.glow * this.treeScale);
                    
                    if (Math.random() < 0.02) {
                        this.drawSparkle(
                            l.x + (Math.random()-0.5)*4,
                            l.y + (Math.random()-0.5)*4,
                            Math.max(2, l.size*2),
                            0.9 + Math.random()*0.6
                        );
                    }
                });

                // 绘制顶部星星 - 确保星星在最前面
                if (this.topStar) {
                    const star = this.topStar;
                    const time = Date.now() / 1000;
                    
                    // 保存当前状态
                    this.ctx.save();
                    
                    // 绘制光晕
                    const glowGradient = this.ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.glowSize
                    );
                    
                    glowGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    glowGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.6)');
                    glowGradient.addColorStop(0.7, 'rgba(255, 140, 0, 0.3)');
                    glowGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    
                    this.ctx.globalCompositeOperation = 'lighter';
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.glowSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // 绘制内层光晕
                    const innerGlowGradient = this.ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.glowSize * 0.6
                    );
                    
                    innerGlowGradient.addColorStop(0, 'rgba(255, 255, 230, 0.9)');
                    innerGlowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.6)');
                    innerGlowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    this.ctx.fillStyle = innerGlowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.glowSize * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // 绘制星星主体 - 使用修复后的绘制函数
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.drawStar(
                        star.x, 
                        star.y, 
                        star.spikes, 
                        star.size, 
                        star.size * star.innerRadius, 
                        '#FFD700', 
                        star.rotation
                    );
                    
                    // 绘制星星高光
                    this.drawStar(
                        star.x, 
                        star.y, 
                        star.spikes, 
                        star.size * 0.7,
                        star.size * 0.7 * star.innerRadius, 
                        '#FFFACD', 
                        star.rotation + 0.1
                    );
                    
                    // 绘制中心亮点
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size * 0.3, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.ctx.fill();
                    
                    // 随机闪烁效果
                    if (Math.random() < 0.15) {
                        this.drawSparkle(
                            star.x + (Math.random()-0.5)*15,
                            star.y + (Math.random()-0.5)*15,
                            3 + Math.random()*4,
                            0.8 + Math.random()*0.6
                        );
                    }
                    
                    // 如果正在闪光
                    if (star._sparkleTimer > 0) {
                        star._sparkleTimer--;
                        const sparkleAlpha = star._sparkleTimer / 15;
                        this.drawSparkle(star.x, star.y, 25, sparkleAlpha * (star._sparkle || 1));
                    }
                    
                    // 恢复状态
                    this.ctx.restore();
                }

                this.ctx.globalCompositeOperation = 'source-over';
                
                // 绘制雪花
                this.snowflakes.forEach(s => {
                    // 检查雪花是否在星星附近
                    if (this.topStar) {
                        const dx = s.x - this.topStar.x;
                        const dy = s.y - this.topStar.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // 如果雪花在星星附近，跳过绘制
                        if (distance < 60) {
                            return;
                        }
                    }
                    
                    switch(s.type) {
                        case 0:
                            this.drawHexagonSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                            break;
                        case 1:
                            this.drawStarSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                            break;
                        case 2:
                            this.drawFlowerSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                            break;
                    }
                });

                this.ctx.globalAlpha = 1.0;
            }

            startAnimation() {
                const animate = () => {
                    this.update();
                    this.draw();
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        window.addEventListener('load', () => new ChristmasAnimation());
    </script>
</body>
</html>