<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Merry Christmas from Zhou</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }
        
        body {
            background: radial-gradient(circle at center, #1a1a3a 0%, #03030c 100%);
            font-family: 'Great Vibes', cursive;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: pointer; /* æ·»åŠ ç‚¹å‡»å…‰æ ‡æç¤º */
        }
        
        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #loading {
            position: fixed;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4ECDC4;
            font-size: 20px;
            z-index: 10;
            transition: opacity 0.5s;
            font-family: 'Arial', sans-serif;
        }

        #textContainer {
            position: fixed;
            bottom: 3%; 
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
            mix-blend-mode: screen;
        }

        #mainText {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(48px, 6vw, 72px);
            font-weight: 400;
            letter-spacing: 3px;
            color: #FFD700;
            text-shadow: 
                0 0 10px rgba(255, 215, 0, 0.8),
                0 0 20px rgba(255, 215, 0, 0.6),
                0 0 30px rgba(255, 215, 0, 0.4),
                0 0 40px rgba(255, 107, 157, 0.3),
                0 5px 15px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateY(30px);
            animation: textFloatIn 2s ease-out forwards 1s;
            position: relative;
            display: inline-block;
        }

        @keyframes textFloatIn {
            0% { opacity: 0; transform: translateY(30px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes textGlow {
            0%, 100% { 
                text-shadow: 
                    0 0 10px rgba(255, 215, 0, 0.8),
                    0 0 20px rgba(255, 215, 0, 0.6),
                    0 0 30px rgba(255, 215, 0, 0.4),
                    0 0 40px rgba(255, 107, 157, 0.3),
                    0 5px 15px rgba(0, 0, 0, 0.5);
            }
            50% { 
                text-shadow: 
                    0 0 15px rgba(255, 215, 0, 1),
                    0 0 25px rgba(255, 215, 0, 0.8),
                    0 0 35px rgba(255, 215, 0, 0.6),
                    0 0 45px rgba(255, 107, 157, 0.5),
                    0 5px 15px rgba(0, 0, 0, 0.5);
            }
        }

        #mainText {
            animation: 
                textFloatIn 2s ease-out forwards 1s,
                textGlow 3s ease-in-out infinite 3s;
        }

        /* ç‚¹å‡»æç¤ºæ ·å¼ */
        .tap-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 215, 0, 0.8);
            font-size: 18px;
            font-family: 'Arial', sans-serif;
            text-align: center;
            z-index: 5;
            animation: pulseHint 2s ease-in-out infinite;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        @keyframes pulseHint {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* ç§»åŠ¨è®¾å¤‡å“åº”å¼è°ƒæ•´ */
        @media screen and (max-height: 500px) {
            #mainText {
                font-size: clamp(36px, 5vw, 48px) !important;
                bottom: 2% !important;
            }
            
            #textContainer {
                bottom: 1% !important;
            }
            
            .tap-hint {
                font-size: 16px;
                top: 20px;
                transform: translateX(-50%);
            }
        }

        /* æ¨ªå±æ¨¡å¼ä¼˜åŒ– */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            #mainText {
                font-size: clamp(32px, 4vw, 40px) !important;
            }
        }

        /* å…¨å±æ¨¡å¼ä¼˜åŒ– */
        :fullscreen, ::backdrop {
            background-color: transparent;
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="christmasCanvas"></canvas>
        <div id="loading"></div>
        <div id="textContainer">
            <div id="mainText">Merry ChristmasğŸ„</div>
        </div>
        <div class="tap-hint" id="tapHint"></div>
    </div>

    <script>
        // å…¨å±åŠŸèƒ½å‡½æ•°
        function requestFullscreen() {
            const elem = document.documentElement;
            
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }

        function toggleFullscreen() {
            const isFullscreen = document.fullscreenElement || 
                                document.webkitFullscreenElement || 
                                document.msFullscreenElement;
            
            if (!isFullscreen) {
                requestFullscreen();
            } else {
                exitFullscreen();
            }
        }

        // æ˜¾ç¤ºç‚¹å‡»æç¤º
        function showTapHint() {
            const tapHint = document.getElementById('tapHint');
            setTimeout(() => {
                tapHint.style.opacity = '1';
            }, 3000);
            
            // 5ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                tapHint.style.opacity = '0';
            }, 8000);
        }

        class ChristmasAnimation {
            constructor() {
                this.canvas = document.getElementById('christmasCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.resizeTimeout = null;
                this.isFullscreen = false;
                
                // ç§»é™¤é¼ æ ‡äº¤äº’ï¼Œæ”¹ä¸ºè‡ªåŠ¨æ—‹è½¬
                this.autoRotation = 0;
                this.rotationSpeed = 0.005; // è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦
                this.growthProgress = 0; // ç”Ÿé•¿è¿›åº¦
                this.maxGrowth = 1; // æœ€å¤§ç”Ÿé•¿å€¼
                
                this.setupCanvas();
                this.initColors();
                this.createScene();
                this.startAnimation();
                
                this.preventScroll();
                
                // æ·»åŠ çª—å£å¤§å°è°ƒæ•´ç›‘å¬
                window.addEventListener('resize', () => this.handleResize());
                
                // æ˜¾ç¤ºç‚¹å‡»æç¤º
                showTapHint();
                
                // ç›‘å¬å…¨å±å˜åŒ–
                this.setupFullscreenListeners();
            }

            setupCanvas() {
                // è·å–æ›´å‡†ç¡®çš„å±å¹•å°ºå¯¸
                const getScreenDimensions = () => {
                    return {
                        width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                        height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                    };
                };
                
                const { width, height } = getScreenDimensions();
                
                this.dpr = Math.min(window.devicePixelRatio || 1, 2); // é™åˆ¶æœ€å¤§DPIç¼©æ”¾
                this.screenWidth = width;
                this.screenHeight = height;
                
                // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                this.canvas.width = this.screenWidth * this.dpr;
                this.canvas.height = this.screenHeight * this.dpr;
                this.canvas.style.width = `${this.screenWidth}px`;
                this.canvas.style.height = `${this.screenHeight}px`;
                
                // é‡ç½®å˜æ¢çŸ©é˜µ
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(this.dpr, this.dpr);
                
                this.centerX = this.screenWidth / 2;
                this.centerY = this.screenHeight / 2;
                
                // æ ‘å¹²ä½ç½®ä¿æŒä¸å˜
                this.trunkBaseY = this.screenHeight * 0.7; 
                
                // æ ‘å† åŸºå‡†ç‚¹å‘ä¸‹ç§»åŠ¨
                this.crownBaseY = this.screenHeight * 0.82; 
                
                // å¢å¤§æ ‘çš„æ¯”ä¾‹å› å­ï¼Œä»800æ”¹ä¸º850ï¼Œä½¿æ•´ä½“ç•¥å°ä¸€ç‚¹
                this.treeScale = Math.min(this.screenWidth, this.screenHeight) / 850;
                
                // éšè—åŠ è½½æç¤º
                setTimeout(() => {
                    this.loading.style.opacity = 0;
                    setTimeout(() => {
                        this.loading.style.display = 'none';
                    }, 500);
                }, 1500);
            }

            setupFullscreenListeners() {
                // ç‚¹å‡»å±å¹•åˆ‡æ¢å…¨å±
                document.addEventListener('click', () => {
                    toggleFullscreen();
                    // éšè—ç‚¹å‡»æç¤º
                    document.getElementById('tapHint').style.opacity = '0';
                });
                
                // ç›‘å¬å…¨å±å˜åŒ–
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
                document.addEventListener('msfullscreenchange', () => this.handleFullscreenChange());
                
                // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒï¼ˆæŒ‰Fé”®è¿›å…¥/é€€å‡ºå…¨å±ï¼‰
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'f' || e.key === 'F') {
                        toggleFullscreen();
                        e.preventDefault();
                    }
                });
            }

            handleFullscreenChange() {
                this.isFullscreen = !!(document.fullscreenElement || 
                                      document.webkitFullscreenElement || 
                                      document.msFullscreenElement);
                
                // å…¨å±çŠ¶æ€å˜åŒ–åé‡æ–°è°ƒæ•´ç”»å¸ƒ
                setTimeout(() => {
                    this.handleResize();
                }, 100);
            }

            handleResize() {
                // é˜²æŠ–å¤„ç†ï¼Œé¿å…é¢‘ç¹é‡ç»˜
                if (this.resizeTimeout) {
                    clearTimeout(this.resizeTimeout);
                }
                
                this.resizeTimeout = setTimeout(() => {
                    this.setupCanvas();
                    this.createScene();
                    // ç¡®ä¿ç”»å¸ƒå°ºå¯¸æ­£ç¡®
                    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
                }, 250);
            }

            preventScroll() {
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('wheel', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('keydown', (e) => {
                    if ([32, 37, 38, 39, 40].includes(e.keyCode)) {
                        e.preventDefault();
                    }
                });
            }

            initColors() {
                this.TREE_COLORS = ["#2E8B57", "#3CB371", "#20B2AA", "#66CDAA", "#00FA9A"];
                this.LIGHT_COLORS = ["#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", "#FFA552", "#93FF9B"];
                this.TRUNK_COLORS = ["#5C3317", "#6F4E37", "#8B4513"];
                // ç¤¼ç›’é¢œè‰²
                this.GIFT_COLORS = [
                    { box: "#FF6B6B", ribbon: "#FFD166" },
                    { box: "#4ECDC4", ribbon: "#FFE66D" },
                    { box: "#95E1D3", ribbon: "#F38181" },
                    { box: "#FF8AF0", ribbon: "#7CE6E6" },
                    { box: "#FFD166", ribbon: "#FF6B9D" },
                    { box: "#A8E6CF", ribbon: "#FFAAA5" },
                    { box: "#FFD3B6", ribbon: "#A8E6CF" },
                    { box: "#D4A5A5", ribbon: "#FFE8E8" },
                ];
                // èºæ—‹ç¯å¸¦é¢œè‰²
                this.SPIRAL_LIGHT_COLORS = [
                    "#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", 
                    "#4ECDC4", "#95E1D3", "#A8E6CF", "#FFD3B6"
                ];
            }

            createScene() {
                this.particles = []; 
                this.lights = [];    
                this.snowflakes = [];
                this.stars = [];     
                this.topStar = null;
                this.gifts = [];     
                this.upperGifts = []; 
                this.topGifts = [];   // æ–°å¢ï¼šé¡¶éƒ¨ç¤¼ç›’
                this.spiralLights = [];

                // åˆ›å»ºåœ£è¯æ ‘ï¼ˆæ ‘å¹²éƒ¨åˆ†ï¼‰
                this.createChristmasTreeTrunk();
                
                // åˆ›å»ºåœ£è¯æ ‘ï¼ˆæ ‘å† éƒ¨åˆ†ï¼‰
                this.createChristmasTreeCrown();
                
                // åˆ›å»ºé›ªèŠ±ï¼ˆå‡å°å°ºå¯¸ï¼‰
                this.createSnowflakes();
                
                // åˆ›å»ºé¡¶éƒ¨æ˜Ÿæ˜Ÿ
                this.createTopStar();
                
                // åˆ›å»ºç¤¼ç›’
                this.createTopGifts();    // å…ˆåˆ›å»ºé¡¶éƒ¨ç¤¼ç›’
                this.createUpperGifts();  // ç„¶ååˆ›å»ºä¸Šéƒ¨ç¤¼ç›’
                this.createGifts();       // æœ€ååˆ›å»ºä¸­éƒ¨ç¤¼ç›’
                
                // åˆ›å»ºèºæ—‹ç¯å¸¦
                this.createSpiralLights();
            }

            createChristmasTreeTrunk() {
                const trunkHeight = 140 * this.treeScale; // å¢åŠ æ ‘å¹²é«˜åº¦
                const trunkRadius = 50 * this.treeScale; // å¢åŠ æ ‘å¹²åŠå¾„
                const trunkCount = 1000; // å¢åŠ æ ‘å¹²ç²’å­æ•°é‡
                
                for (let i = 0; i < trunkCount; i++) {
                    const p = i / trunkCount;
                    const y = this.trunkBaseY + p * trunkHeight;
                    const angle = i * 2.39996;
                    const currentRadius = trunkRadius * (1 - 0.2 * p);
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.5 + Math.random() * 0.5);
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    let color;
                    if (z > 0) {
                        color = this.TRUNK_COLORS[2];
                    } else if (y > this.trunkBaseY + trunkHeight * 0.6) {
                        color = this.TRUNK_COLORS[0];
                    } else {
                        color = this.TRUNK_COLORS[1];
                    }
                    this.particles.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: color,
                        size: Math.random() * 3.5 + 3, // è°ƒæ•´ç²’å­å°ºå¯¸
                        swaySpeed: 0,
                        swayOffset: 0,
                        isTrunk: true,
                        growth: 1
                    });
                }
            }

            createChristmasTreeCrown() {
                const particleCount = 3500; // å¢åŠ ç²’å­æ•°é‡
                const treeHeight = 620 * this.treeScale; // å¢åŠ æ ‘å† é«˜åº¦
                const maxRadius = 280 * this.treeScale; // å¢åŠ æœ€å¤§åŠå¾„
                
                // æ—‹è½¬å¼å¢é•¿ï¼šèºæ—‹è§’åº¦
                const spiralFactor = 10; // èºæ—‹ç³»æ•°ï¼Œå€¼è¶Šå¤§èºæ—‹è¶Šç´§å¯†
                
                for (let i = 0; i < particleCount; i++) {
                    const p = i / particleCount; 
                    
                    // æ·»åŠ èºæ—‹æ•ˆæœ
                    const spiralAngle = i * 2.39996 + p * spiralFactor;
                    
                    const currentHeight = treeHeight * p;
                    const currentRadius = maxRadius * (1 - p);
                    
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.8 + Math.random() * 0.4);
                    
                    const x = Math.cos(spiralAngle) * r;
                    const y = this.crownBaseY - currentHeight; // ä½¿ç”¨æ ‘å† åŸºå‡†ç‚¹
                    const z = Math.sin(spiralAngle) * r;

                    if (Math.random() < 0.18) {
                        const color = this.LIGHT_COLORS[Math.floor(Math.random() * this.LIGHT_COLORS.length)];
                        const size = Math.random() * 3.5 + 2.5; // è°ƒæ•´ç¯å…‰å°ºå¯¸
                        const pulseSpeed = 1.0 + Math.random() * 3.5;
                        const phase = Math.random() * Math.PI * 2;
                        const baseAlpha = 0.5 + Math.random() * 0.6;
                        const sparkleChance = Math.random() < 0.15 ? 0.01 + Math.random()*0.03 : 0;
                        const glow = 8 + Math.random() * 24; // è°ƒæ•´å‘å…‰èŒƒå›´
                        this.lights.push({
                            x: x, y: y, z: z,
                            baseX: x, baseY: y,
                            color: color,
                            size: size,
                            blinkSpeed: pulseSpeed,
                            blinkOffset: phase,
                            baseAlpha: baseAlpha,
                            sparkleChance: sparkleChance,
                            glow: glow,
                            flickerSeed: Math.random() * 1000,
                            growth: 1,
                            spiralAngle: spiralAngle
                        });
                    } else {
                        this.particles.push({
                            x: x, y: y, z: z,
                            baseX: x, baseY: y,
                            color: this.TREE_COLORS[Math.floor(Math.random() * this.TREE_COLORS.length)],
                            size: Math.random() * 1.8 + 0.6, // è°ƒæ•´æå¶ç²’å­å°ºå¯¸
                            swaySpeed: Math.random() * 2 + 1,
                            swayOffset: Math.random() * Math.PI * 2,
                            isTrunk: false,
                            growth: 1,
                            spiralAngle: spiralAngle
                        });
                    }
                }
            }

            createTopGifts() {
                const treeHeight = 620 * this.treeScale; // è°ƒæ•´æ ‘é«˜
                const maxRadius = 280 * this.treeScale; // å¢åŠ æœ€å¤§åŠå¾„
                const topGiftCount = 5; // å¢åŠ é¡¶éƒ¨ç¤¼ç›’æ•°é‡
                const spiralFactor = 12; // èºæ—‹ç³»æ•°è¾ƒå¤§ï¼Œå½¢æˆæ›´ç´§å¯†çš„èºæ—‹
                
                for (let i = 0; i < topGiftCount; i++) {
                    // é¡¶éƒ¨ç¤¼ç›’ä½ç½®ï¼šéå¸¸é è¿‘æ ‘çš„é¡¶éƒ¨ï¼Œåœ¨æ˜Ÿæ˜Ÿä¸‹æ–¹
                    const heightRatio = 0.05 + Math.random() * 0.08; // 0.05-0.13ï¼Œéå¸¸é ä¸Š
                    const currentHeight = treeHeight * heightRatio;
                    const y = this.crownBaseY - currentHeight; // ä½¿ç”¨æ ‘å† åŸºå‡†ç‚¹
                    
                    // é¡¶éƒ¨ç¤¼ç›’åŠå¾„è¾ƒå°ï¼Œç´§è´´æ ‘é¡¶
                    const radiusRatio = 0.3 + Math.random() * 0.3; // 0.3-0.6
                    const currentRadius = maxRadius * (1 - heightRatio) * radiusRatio;
                    
                    // æ·»åŠ èºæ—‹æ•ˆæœ
                    const spiralAngle = i * (Math.PI * 2 / topGiftCount) + heightRatio * spiralFactor;
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    // é€‰æ‹©ç‰¹æ®Šçš„ç¤¼ç›’é¢œè‰²ï¼Œè®©é¡¶éƒ¨ç¤¼ç›’æ›´æ˜¾çœ¼
                    const specialColors = [
                        { box: "#FF6B6B", ribbon: "#FFD166" }, // çº¢è‰²+é‡‘è‰²
                        { box: "#4ECDC4", ribbon: "#FFE66D" }, // é’è‰²+é»„è‰²
                        { box: "#FF8AF0", ribbon: "#7CE6E6" }, // ç²‰è‰²+é’è‰²
                        { box: "#FFD166", ribbon: "#FF6B9D" }, // é‡‘è‰²+ç²‰è‰²
                        { box: "#A8E6CF", ribbon: "#FFAAA5" }  // æµ…ç»¿+ç²‰è‰²
                    ];
                    const colorSet = specialColors[i % specialColors.length];
                    
                    // é¡¶éƒ¨ç¤¼ç›’è¾ƒå¤§ï¼Œæ›´æ˜¾çœ¼
                    const size = (0.45 + Math.random() * 0.45) * this.treeScale * 25; // è°ƒæ•´ç¤¼ç›’å°ºå¯¸
                    
                    const rotation = Math.random() * Math.PI * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 0.015; // æ—‹è½¬é€Ÿåº¦è¾ƒå¿«
                    const swaySpeed = 0.8 + Math.random() * 1.5; // æ‘†åŠ¨è¾ƒå¿«
                    const swayOffset = Math.random() * Math.PI * 2;
                    
                    this.topGifts.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: colorSet.box,
                        ribbonColor: colorSet.ribbon,
                        size: size,
                        rotation: rotation,
                        rotationSpeed: rotationSpeed,
                        swaySpeed: swaySpeed,
                        swayOffset: swayOffset,
                        timeOffset: Math.random() * 1000,
                        glow: 0,
                        sparkleTimer: 0,
                        sparkleIntensity: 0,
                        growth: 1,
                        spiralAngle: spiralAngle,
                        layer: "top", // æ ‡è®°ä¸ºé¡¶å±‚ç¤¼ç›’
                        floatHeight: 5 + Math.random() * 10, // æµ®åŠ¨é«˜åº¦
                        floatSpeed: 1 + Math.random() * 2    // æµ®åŠ¨é€Ÿåº¦
                    });
                }
            }

            createUpperGifts() {
                const treeHeight = 620 * this.treeScale; // è°ƒæ•´æ ‘é«˜
                const maxRadius = 280 * this.treeScale; // å¢åŠ æœ€å¤§åŠå¾„
                const upperGiftCount = 8; // å¢åŠ ä¸Šéƒ¨ç¤¼ç›’æ•°é‡
                const spiralFactor = 8;
                
                for (let i = 0; i < upperGiftCount; i++) {
                    // ç¤¼ç›’ä½ç½®ï¼šæ ‘çš„ä¸Šéƒ¨åŒºåŸŸ
                    const heightRatio = 0.15 + Math.random() * 0.2; // 0.15-0.35
                    const currentHeight = treeHeight * heightRatio;
                    const y = this.crownBaseY - currentHeight; // ä½¿ç”¨æ ‘å† åŸºå‡†ç‚¹
                    
                    const radiusRatio = 0.6 + Math.random() * 0.3; // 0.6-0.9
                    const currentRadius = maxRadius * (1 - heightRatio) * radiusRatio;
                    
                    // æ·»åŠ èºæ—‹æ•ˆæœ
                    const spiralAngle = i * (Math.PI * 2 / upperGiftCount) + heightRatio * spiralFactor;
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    const colorSet = this.GIFT_COLORS[Math.floor(Math.random() * this.GIFT_COLORS.length)];
                    
                    const size = (0.65 + Math.random() * 0.65) * this.treeScale * 28; // è°ƒæ•´ç¤¼ç›’å°ºå¯¸
                    
                    const rotation = Math.random() * Math.PI * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 0.012;
                    const swaySpeed = 0.6 + Math.random() * 1.2;
                    const swayOffset = Math.random() * Math.PI * 2;
                    
                    this.upperGifts.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: colorSet.box,
                        ribbonColor: colorSet.ribbon,
                        size: size,
                        rotation: rotation,
                        rotationSpeed: rotationSpeed,
                        swaySpeed: swaySpeed,
                        swayOffset: swayOffset,
                        timeOffset: Math.random() * 1000,
                        glow: 0,
                        sparkleTimer: 0,
                        sparkleIntensity: 0,
                        growth: 1,
                        spiralAngle: spiralAngle,
                        layer: "upper"
                    });
                }
            }

            createGifts() {
                const treeHeight = 620 * this.treeScale; // è°ƒæ•´æ ‘é«˜
                const maxRadius = 280 * this.treeScale; // å¢åŠ æœ€å¤§åŠå¾„
                const giftCount = 6; // å¢åŠ ä¸­éƒ¨ç¤¼ç›’æ•°é‡
                const spiralFactor = 8;
                
                for (let i = 0; i < giftCount; i++) {
                    const heightRatio = 0.3 + Math.random() * 0.2; // 0.3-0.5
                    const currentHeight = treeHeight * heightRatio;
                    const y = this.crownBaseY - currentHeight; // ä½¿ç”¨æ ‘å† åŸºå‡†ç‚¹
                    
                    const radiusRatio = 0.5 + Math.random() * 0.4; // 0.5-0.9
                    const currentRadius = maxRadius * (1 - heightRatio) * radiusRatio;
                    
                    const spiralAngle = i * (Math.PI * 2 / giftCount) + heightRatio * spiralFactor;
                    
                    const x = Math.cos(spiralAngle) * currentRadius;
                    const z = Math.sin(spiralAngle) * currentRadius;
                    
                    const colorSet = this.GIFT_COLORS[Math.floor(Math.random() * this.GIFT_COLORS.length)];
                    
                    const size = (0.75 + Math.random() * 0.75) * this.treeScale * 30; // è°ƒæ•´ç¤¼ç›’å°ºå¯¸
                    
                    const rotation = Math.random() * Math.PI * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 0.01;
                    const swaySpeed = 0.5 + Math.random() * 1.0;
                    const swayOffset = Math.random() * Math.PI * 2;
                    
                    this.gifts.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: colorSet.box,
                        ribbonColor: colorSet.ribbon,
                        size: size,
                        rotation: rotation,
                        rotationSpeed: rotationSpeed,
                        swaySpeed: swaySpeed,
                        swayOffset: swayOffset,
                        timeOffset: Math.random() * 1000,
                        glow: 0,
                        sparkleTimer: 0,
                        sparkleIntensity: 0,
                        growth: 1,
                        spiralAngle: spiralAngle,
                        layer: "middle"
                    });
                }
            }

            createSpiralLights() {
                const treeHeight = 620 * this.treeScale; // è°ƒæ•´æ ‘é«˜
                const maxRadius = 280 * this.treeScale; // å¢åŠ æœ€å¤§åŠå¾„
                const spiralCount = 100; // å¢åŠ èºæ—‹ç¯å¸¦æ•°é‡
                const spiralTurns = 5;
                
                for (let i = 0; i < spiralCount; i++) {
                    const t = i / spiralCount;
                    const currentHeight = treeHeight * t;
                    const y = this.crownBaseY - currentHeight; // ä½¿ç”¨æ ‘å† åŸºå‡†ç‚¹
                    
                    const angle = t * Math.PI * 2 * spiralTurns + t * 10;
                    
                    const currentRadius = maxRadius * (1 - t * 0.8) * (0.7 + Math.random() * 0.3);
                    
                    const x = Math.cos(angle) * currentRadius;
                    const z = Math.sin(angle) * currentRadius;
                    
                    const color = this.SPIRAL_LIGHT_COLORS[i % this.SPIRAL_LIGHT_COLORS.length];
                    
                    const size = 1.8 + Math.random() * 1.8; // è°ƒæ•´ç¯å¸¦å°ºå¯¸
                    const pulseSpeed = 2.0 + Math.random() * 2.0;
                    const phase = Math.random() * Math.PI * 2;
                    const baseAlpha = 0.6 + Math.random() * 0.4;
                    const glow = 10 + Math.random() * 20; // è°ƒæ•´å‘å…‰èŒƒå›´
                    
                    this.spiralLights.push({
                        x: x, y: y, z: z,
                        baseX: x, baseY: y,
                        color: color,
                        size: size,
                        pulseSpeed: pulseSpeed,
                        phase: phase,
                        baseAlpha: baseAlpha,
                        glow: glow,
                        flickerSeed: Math.random() * 1000,
                        trailLength: 3 + Math.floor(Math.random() * 4),
                        trailOffset: 0,
                        growth: 1,
                        spiralAngle: angle
                    });
                }
            }

            createTopStar() {
                const treeHeight = 620 * this.treeScale; // è°ƒæ•´æ ‘é«˜
                const topY = this.crownBaseY - treeHeight; // ä½¿ç”¨æ ‘å† åŸºå‡†ç‚¹
                
                this.topStar = {
                    x: this.centerX,
                    y: topY - 30, // å°†æ˜Ÿæ˜Ÿå†ä¸Šç§»ä¸€äº›ï¼Œä¸ºé¡¶éƒ¨ç¤¼ç›’è…¾å‡ºæ›´å¤šç©ºé—´
                    size: 30 * this.treeScale, // è°ƒæ•´æ˜Ÿæ˜Ÿå°ºå¯¸
                    color: '#FFD700',
                    rotation: 0,
                    rotationSpeed: 0.01,
                    pulseSpeed: 0.8,
                    glowSize: 48 * this.treeScale, // è°ƒæ•´æ˜Ÿæ˜Ÿå‘å…‰èŒƒå›´
                    spikes: 5,
                    innerRadius: 0.4,
                    outerRadius: 1,
                    time: 0,
                    sparkleInterval: 0,
                    growth: 1
                };
            }

            createSnowflakes() {
                for (let i = 0; i < 500; i++) { // å¢åŠ é›ªèŠ±æ•°é‡
                    this.snowflakes.push({
                        x: Math.random() * this.screenWidth,
                        y: Math.random() * this.screenHeight,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 4 + 3, // å‡å°é›ªèŠ±å°ºå¯¸
                        baseSize: Math.random() * 4 + 3,
                        speedY: Math.random() * 1 + 0.5,
                        swayAmp: Math.random() * 2,
                        swayFreq: Math.random() * 0.02,
                        opacity: Math.random() * 0.6 + 0.3,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.05,
                        type: Math.floor(Math.random() * 3),
                        growth: 0,
                        targetSize: Math.random() * 1.8 + 1,
                        growthSpeed: Math.random() * 0.003 + 0.001
                    });
                }
            }

            noise(seed, t) {
                return (Math.sin(t * 0.7 + seed * 12.345) + Math.sin(t * 1.3 + seed * 4.56)*0.5) * 0.5;
            }

            update() {
                const time = Date.now() / 1000;
                
                // è‡ªåŠ¨æ—‹è½¬
                this.autoRotation += this.rotationSpeed;
                
                // ç¼“æ…¢ç”Ÿé•¿
                if (this.growthProgress < this.maxGrowth) {
                    this.growthProgress += 0.001;
                }
                
                // æ›´æ–°ç²’å­ä½ç½®
                this.particles.forEach(p => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, p.growth + this.growthProgress);
                    
                    const rotatedX = p.baseX * cos - p.z * sin;
                    const rotatedZ = p.z * cos + p.baseX * sin;
                    
                    p.x = rotatedX * growthFactor + this.centerX;
                    
                    if (!p.isTrunk) {
                        const spiralSway = Math.sin(time * 0.5 + p.spiralAngle) * 2;
                        p.y = p.baseY + Math.sin(time * p.swaySpeed + p.swayOffset) * 2 * growthFactor + spiralSway;
                    } else {
                        p.y = p.baseY * growthFactor;
                    }
                });

                // æ›´æ–°ç¯å…‰
                this.lights.forEach(l => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, l.growth + this.growthProgress);
                    
                    const rotatedX = l.baseX * cos - l.z * sin;
                    const rotatedZ = l.z * cos + l.baseX * sin;

                    l.x = rotatedX * growthFactor + this.centerX;
                    l.y = l.baseY * growthFactor;

                    const sinPart = (Math.sin(time * l.blinkSpeed + l.blinkOffset) + 1) / 2;
                    const noisePart = (this.noise(l.flickerSeed, time) + 1) / 2 * 0.25;
                    l.alpha = Math.min(1, l.baseAlpha * (0.6 + 0.8 * sinPart) + noisePart);

                    l.x += Math.sin(time * 2 + l.flickerSeed + l.spiralAngle) * 0.8 * growthFactor;
                    l.y += Math.cos(time * 1.5 + l.flickerSeed + l.spiralAngle) * 0.6 * growthFactor;

                    if (l.sparkleChance > 0 && Math.random() < l.sparkleChance) {
                        l._sparkle = 0.9 + Math.random() * 0.5;
                        l._sparkleTimer = 6 + Math.floor(Math.random()*8);
                    }
                    if (l._sparkleTimer > 0) {
                        l._sparkleTimer--;
                        l.alpha = Math.min(1.4, l.alpha + (l._sparkle || 0));
                        if (l._sparkleTimer === 0) { l._sparkle = 0; }
                    }
                });

                // æ›´æ–°é¡¶éƒ¨ç¤¼ç›’
                this.topGifts.forEach(gift => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, gift.growth + this.growthProgress);
                    
                    const rotatedX = gift.baseX * cos - gift.z * sin;
                    const rotatedZ = gift.z * cos + gift.baseX * sin;

                    gift.x = rotatedX * growthFactor + this.centerX;
                    
                    // é¡¶éƒ¨ç¤¼ç›’æœ‰ç‰¹æ®Šçš„æµ®åŠ¨æ•ˆæœ
                    const floatOffset = Math.sin(time * gift.floatSpeed + gift.timeOffset) * gift.floatHeight;
                    const spiralSway = Math.sin(time * 0.3 + gift.spiralAngle) * 4;
                    gift.y = gift.baseY * growthFactor + Math.sin(time * gift.swaySpeed + gift.swayOffset) * 3 + spiralSway + floatOffset;
                    
                    // é¡¶éƒ¨ç¤¼ç›’æ—‹è½¬æ›´å¿«
                    gift.rotation += gift.rotationSpeed + 0.004;
                    
                    // é¡¶éƒ¨ç¤¼ç›’å‘å…‰æ•ˆæœæœ€å¼º
                    gift.glow = 0.5 + 0.4 * Math.sin(time * 2.0 + gift.timeOffset);
                    
                    // é¡¶éƒ¨ç¤¼ç›’é—ªçƒæ›´é¢‘ç¹
                    if (Math.random() < 0.015) {
                        gift.sparkleTimer = 20;
                        gift.sparkleIntensity = 0.6 + Math.random() * 0.6;
                    }
                    
                    if (gift.sparkleTimer > 0) {
                        gift.sparkleTimer--;
                    }
                });

                // æ›´æ–°ä¸Šéƒ¨ç¤¼ç›’
                this.upperGifts.forEach(gift => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, gift.growth + this.growthProgress);
                    
                    const rotatedX = gift.baseX * cos - gift.z * sin;
                    const rotatedZ = gift.z * cos + gift.baseX * sin;

                    gift.x = rotatedX * growthFactor + this.centerX;
                    
                    const spiralSway = Math.sin(time * 0.25 + gift.spiralAngle) * 3;
                    gift.y = gift.baseY * growthFactor + Math.sin(time * gift.swaySpeed + gift.swayOffset) * 2.5 + spiralSway;
                    
                    gift.rotation += gift.rotationSpeed + 0.003;
                    
                    gift.glow = 0.4 + 0.3 * Math.sin(time * 1.8 + gift.timeOffset);
                    
                    if (Math.random() < 0.012) {
                        gift.sparkleTimer = 18;
                        gift.sparkleIntensity = 0.5 + Math.random() * 0.5;
                    }
                    
                    if (gift.sparkleTimer > 0) {
                        gift.sparkleTimer--;
                    }
                });

                // æ›´æ–°ä¸­éƒ¨ç¤¼ç›’
                this.gifts.forEach(gift => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, gift.growth + this.growthProgress);
                    
                    const rotatedX = gift.baseX * cos - gift.z * sin;
                    const rotatedZ = gift.z * cos + gift.baseX * sin;

                    gift.x = rotatedX * growthFactor + this.centerX;
                    
                    const spiralSway = Math.sin(time * 0.2 + gift.spiralAngle) * 2;
                    gift.y = gift.baseY * growthFactor + Math.sin(time * gift.swaySpeed + gift.swayOffset) * 2 + spiralSway;
                    
                    gift.rotation += gift.rotationSpeed + 0.002;
                    
                    gift.glow = 0.3 + 0.2 * Math.sin(time * 1.5 + gift.timeOffset);
                    
                    if (Math.random() < 0.01) {
                        gift.sparkleTimer = 15;
                        gift.sparkleIntensity = 0.4 + Math.random() * 0.4;
                    }
                    
                    if (gift.sparkleTimer > 0) {
                        gift.sparkleTimer--;
                    }
                });

                // æ›´æ–°èºæ—‹ç¯å¸¦
                this.spiralLights.forEach(light => {
                    const rotation = this.autoRotation;
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    
                    const growthFactor = Math.min(1, light.growth + this.growthProgress);
                    
                    const rotatedX = light.baseX * cos - light.z * sin;
                    const rotatedZ = light.z * cos + light.baseX * sin;

                    light.x = rotatedX * growthFactor + this.centerX;
                    light.y = light.baseY * growthFactor;
                    
                    const sinPart = (Math.sin(time * light.pulseSpeed + light.phase + light.spiralAngle) + 1) / 2;
                    const noisePart = (this.noise(light.flickerSeed, time) + 1) / 2 * 0.3;
                    light.alpha = Math.min(1, light.baseAlpha * (0.7 + 0.6 * sinPart) + noisePart);
                    
                    light.trailOffset = (light.trailOffset + 1) % (light.trailLength + 1);
                });

                // æ›´æ–°é›ªèŠ±
                this.snowflakes.forEach(s => {
                    if (s.growth < s.targetSize) {
                        s.growth += s.growthSpeed;
                    } else {
                        s.growth = 0;
                        s.targetSize = Math.random() * 1.8 + 1;
                    }
                    
                    const currentSize = s.baseSize * (1 + s.growth);
                    
                    s.y += s.speedY * s.z; 
                    s.x += Math.sin(time + s.y * 0.01) * s.swayAmp;
                    s.rotation += s.rotationSpeed * (1 + s.growth * 0.5);
                    
                    s.size = currentSize;
                    
                    if (s.y > this.screenHeight) {
                        s.y = -10;
                        s.x = Math.random() * this.screenWidth;
                        s.size = s.baseSize = Math.random() * 4 + 3; // æ›´æ–°ä¸ºæ–°çš„åŸºç¡€å°ºå¯¸
                        s.growth = 0;
                        s.targetSize = Math.random() * 1.8 + 1;
                    }
                    if (s.x > this.screenWidth) s.x = 0;
                    if (s.x < 0) s.x = this.screenWidth;
                });

                // æ›´æ–°é¡¶éƒ¨æ˜Ÿæ˜Ÿ
                if (this.topStar) {
                    this.topStar.time = time;
                    this.topStar.rotation += this.topStar.rotationSpeed;
                    
                    this.topStar.size = 30 * this.treeScale + Math.sin(time * this.topStar.pulseSpeed) * 3.5; // è°ƒæ•´è„‰åŠ¨å¹…åº¦
                    this.topStar.glowSize = 48 * this.treeScale + Math.sin(time * 1.5) * 8; // è°ƒæ•´è„‰åŠ¨å¹…åº¦
                    
                    this.topStar.sparkleInterval++;
                    if (this.topStar.sparkleInterval > 30 + Math.random() * 50) {
                        this.topStar.sparkleInterval = 0;
                        this.topStar._sparkle = 2.0 + Math.random() * 1.5;
                        this.topStar._sparkleTimer = 15;
                    }
                }
            }

            drawLightGlow(x, y, size, color, alpha, glow) {
                const ctx = this.ctx;
                const g = ctx.createRadialGradient(x, y, 0, x, y, glow);
                g.addColorStop(0, `rgba(255,255,255,${Math.min(1, alpha*1.2)})`);
                g.addColorStop(0.1, this.hexToRgba(color, alpha));
                g.addColorStop(0.6, this.hexToRgba(color, alpha*0.28));
                g.addColorStop(1, this.hexToRgba(color, 0));
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, glow, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI*2);
                ctx.fillStyle = this.hexToRgba(color, Math.min(1, alpha*1.1));
                ctx.fill();
            }

            drawSpiralLight(x, y, size, color, alpha, glow, trailLength, trailOffset) {
                const ctx = this.ctx;
                
                for (let i = 0; i < trailLength; i++) {
                    if (i === trailOffset) continue;
                    
                    const trailAlpha = alpha * (1 - i / trailLength) * 0.3;
                    const trailGlow = glow * (1 - i / trailLength * 0.7);
                    
                    const g = ctx.createRadialGradient(x, y, 0, x, y, trailGlow);
                    g.addColorStop(0, this.hexToRgba(color, trailAlpha * 0.5));
                    g.addColorStop(0.3, this.hexToRgba(color, trailAlpha * 0.3));
                    g.addColorStop(1, this.hexToRgba(color, 0));
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, trailGlow, 0, Math.PI*2);
                    ctx.fill();
                }
                
                this.drawLightGlow(x, y, size, color, alpha, glow);
            }

            drawGift(x, y, size, rotation, boxColor, ribbonColor, glow = 0, sparkle = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                if (glow > 0) {
                    ctx.globalCompositeOperation = 'lighter';
                    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
                    glowGradient.addColorStop(0, this.hexToRgba(boxColor, glow * 0.3));
                    glowGradient.addColorStop(1, this.hexToRgba(boxColor, 0));
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                ctx.fillStyle = boxColor;
                ctx.fillRect(-size/2, -size/2, size, size);
                
                ctx.fillStyle = this.hexToRgba('#FFFFFF', 0.15);
                ctx.fillRect(-size/2, -size/2, size * 0.8, size * 0.12);
                ctx.fillRect(-size/2, -size/2, size * 0.12, size * 0.8);
                
                ctx.fillStyle = ribbonColor;
                ctx.fillRect(-size/2, -size/6, size, size/3);
                ctx.fillRect(-size/6, -size/2, size/3, size);
                
                ctx.beginPath();
                ctx.arc(0, 0, size/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.hexToRgba('#FFFFFF', 0.3);
                ctx.beginPath();
                ctx.arc(-size/8, -size/8, size/8, 0, Math.PI * 2);
                ctx.arc(size/8, -size/8, size/8, 0, Math.PI * 2);
                ctx.arc(-size/8, size/8, size/8, 0, Math.PI * 2);
                ctx.arc(size/8, size/8, size/8, 0, Math.PI * 2);
                ctx.fill();
                
                if (sparkle > 0) {
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = `rgba(255, 255, 255, ${sparkle})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                ctx.restore();
            }

            drawStar(x, y, spikes, outerRadius, innerRadius, color, rotation = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                const angleStep = (Math.PI * 2) / spikes;
                const halfAngleStep = angleStep / 2;
                
                ctx.beginPath();
                
                for (let i = 0; i < spikes; i++) {
                    const outerAngle = i * angleStep - Math.PI / 2;
                    const outerX = Math.cos(outerAngle) * outerRadius;
                    const outerY = Math.sin(outerAngle) * outerRadius;
                    
                    const innerAngle = outerAngle + halfAngleStep;
                    const innerX = Math.cos(innerAngle) * innerRadius;
                    const innerY = Math.sin(innerAngle) * innerRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    
                    ctx.lineTo(innerX, innerY);
                }
                
                const firstOuterX = Math.cos(-Math.PI / 2) * outerRadius;
                const firstOuterY = Math.sin(-Math.PI / 2) * outerRadius;
                ctx.lineTo(firstOuterX, firstOuterY);
                
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            drawHexagonSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    ctx.lineWidth = size * 0.15;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(size * 0.4, size * 0.5);
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.4, size * 0.5);
                    
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(size * 0.3, size * 0.6);
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(-size * 0.3, size * 0.6);
                    
                    ctx.lineWidth = size * 0.1;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            drawStarSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    
                    ctx.moveTo(size * 0.2, size * 0.4);
                    ctx.lineTo(-size * 0.2, size * 0.4);
                    ctx.moveTo(size * 0.15, size * 0.7);
                    ctx.lineTo(-size * 0.15, size * 0.7);
                    
                    ctx.lineWidth = size * 0.08;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
                    ctx.stroke();
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                ctx.restore();
            }

            drawFlowerSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(size * 0.3, size * 0.2, 0, size);
                    ctx.quadraticCurveTo(-size * 0.3, size * 0.2, 0, 0);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.5);
                    ctx.lineTo(0, size * 0.8);
                    ctx.lineWidth = size * 0.05;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            hexToRgba(hex, alpha=1) {
                const h = hex.replace('#','');
                const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r},${g},${b},${alpha})`;
            }

            drawSparkle(x, y, size, intensity) {
                const ctx = this.ctx;
                const len = size * (1 + intensity * 0.6);
                ctx.save();
                ctx.globalAlpha = Math.min(1, intensity);
                ctx.lineWidth = Math.max(1, size * 0.12);
                ctx.lineCap = 'round';
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.moveTo(x - len, y);
                ctx.lineTo(x + len, y);
                ctx.moveTo(x, y - len);
                ctx.lineTo(x, y + len);
                ctx.stroke();
                ctx.restore();
            }

            draw() {
                this.ctx.fillStyle = "#0a0a2a";
                this.ctx.fillRect(0, 0, this.screenWidth, this.screenHeight);

                this.ctx.globalCompositeOperation = 'lighter';

                this.particles.forEach(p => {
                    this.ctx.beginPath();
                    const sizeMultiplier = p.isTrunk ? 1.5 : 1;
                    const growthFactor = Math.min(1, p.growth + this.growthProgress);
                    this.ctx.arc(p.x, p.y, p.size * this.treeScale * sizeMultiplier * growthFactor, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.isTrunk ? 0.9 : 0.6;
                    this.ctx.fill();
                });

                // ç»˜åˆ¶èºæ—‹ç¯å¸¦
                this.spiralLights.forEach(light => {
                    const growthFactor = Math.min(1, light.growth + this.growthProgress);
                    this.drawSpiralLight(
                        light.x,
                        light.y,
                        light.size * this.treeScale * growthFactor,
                        light.color,
                        light.alpha,
                        light.glow * this.treeScale * growthFactor,
                        light.trailLength,
                        light.trailOffset
                    );
                });

                // ç»˜åˆ¶ä¸­éƒ¨ç¤¼ç›’
                this.gifts.forEach(gift => {
                    const sparkleIntensity = gift.sparkleTimer > 0 ? 
                        (gift.sparkleIntensity * (gift.sparkleTimer / 15)) : 0;
                    
                    this.drawGift(
                        gift.x, 
                        gift.y, 
                        gift.size * Math.min(1, gift.growth + this.growthProgress), 
                        gift.rotation, 
                        gift.color, 
                        gift.ribbonColor, 
                        gift.glow,
                        sparkleIntensity
                    );
                });

                // ç»˜åˆ¶ä¸Šéƒ¨ç¤¼ç›’
                this.upperGifts.forEach(gift => {
                    const sparkleIntensity = gift.sparkleTimer > 0 ? 
                        (gift.sparkleIntensity * (gift.sparkleTimer / 18)) : 0;
                    
                    this.drawGift(
                        gift.x, 
                        gift.y, 
                        gift.size * Math.min(1, gift.growth + this.growthProgress), 
                        gift.rotation, 
                        gift.color, 
                        gift.ribbonColor, 
                        gift.glow,
                        sparkleIntensity
                    );
                });

                // ç»˜åˆ¶é¡¶éƒ¨ç¤¼ç›’ï¼ˆæœ€åç»˜åˆ¶ï¼Œåœ¨æœ€ä¸Šå±‚ï¼‰
                this.topGifts.forEach(gift => {
                    const sparkleIntensity = gift.sparkleTimer > 0 ? 
                        (gift.sparkleIntensity * (gift.sparkleTimer / 20)) : 0;
                    
                    this.drawGift(
                        gift.x, 
                        gift.y, 
                        gift.size * Math.min(1, gift.growth + this.growthProgress), 
                        gift.rotation, 
                        gift.color, 
                        gift.ribbonColor, 
                        gift.glow,
                        sparkleIntensity
                    );
                });

                this.lights.forEach(l => {
                    const growthFactor = Math.min(1, l.growth + this.growthProgress);
                    let depthBoost = l.z > 0 ? 1.1 : 1.0;
                    this.drawLightGlow(l.x, l.y, l.size * this.treeScale * growthFactor, l.color, l.alpha * depthBoost, l.glow * this.treeScale * growthFactor);
                    
                    if (Math.random() < 0.02) {
                        this.drawSparkle(
                            l.x + (Math.random()-0.5)*4,
                            l.y + (Math.random()-0.5)*4,
                            Math.max(2, l.size*2) * growthFactor,
                            0.9 + Math.random()*0.6
                        );
                    }
                });

                if (this.topStar) {
                    const star = this.topStar;
                    const time = Date.now() / 1000;
                    const growthFactor = Math.min(1, star.growth + this.growthProgress);
                    
                    this.ctx.save();
                    
                    const glowGradient = this.ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.glowSize * growthFactor
                    );
                    
                    glowGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    glowGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.6)');
                    glowGradient.addColorStop(0.7, 'rgba(255, 140, 0, 0.3)');
                    glowGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    
                    this.ctx.globalCompositeOperation = 'lighter';
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.glowSize * growthFactor, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const innerGlowGradient = this.ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.glowSize * 0.6 * growthFactor
                    );
                    
                    innerGlowGradient.addColorStop(0, 'rgba(255, 255, 230, 0.9)');
                    innerGlowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.6)');
                    innerGlowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    
                    this.ctx.fillStyle = innerGlowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.glowSize * 0.6 * growthFactor, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.drawStar(
                        star.x, 
                        star.y, 
                        star.spikes, 
                        star.size * growthFactor, 
                        star.size * star.innerRadius * growthFactor, 
                        '#FFD700', 
                        star.rotation
                    );
                    
                    this.drawStar(
                        star.x, 
                        star.y, 
                        star.spikes, 
                        star.size * 0.7 * growthFactor,
                        star.size * 0.7 * star.innerRadius * growthFactor, 
                        '#FFFACD', 
                        star.rotation + 0.1
                    );
                    
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size * 0.3 * growthFactor, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.ctx.fill();
                    
                    if (Math.random() < 0.15) {
                        this.drawSparkle(
                            star.x + (Math.random()-0.5)*15,
                            star.y + (Math.random()-0.5)*15,
                            3 + Math.random()*4,
                            0.8 + Math.random()*0.6
                        );
                    }
                    
                    if (star._sparkleTimer > 0) {
                        star._sparkleTimer--;
                        const sparkleAlpha = star._sparkleTimer / 15;
                        this.drawSparkle(star.x, star.y, 25, sparkleAlpha * (star._sparkle || 1));
                    }
                    
                    this.ctx.restore();
                }

                this.ctx.globalCompositeOperation = 'source-over';
                
                // ç»˜åˆ¶é›ªèŠ±
                this.snowflakes.forEach(s => {
                    if (this.topStar) {
                        const dx = s.x - this.topStar.x;
                        const dy = s.y - this.topStar.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 60) {
                            return;
                        }
                    }
                    
                    switch(s.type) {
                        case 0:
                            this.drawHexagonSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                            break;
                        case 1:
                            this.drawStarSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                            break;
                        case 2:
                            this.drawFlowerSnowflake(s.x, s.y, s.size, s.rotation, s.opacity);
                            break;
                    }
                });

                this.ctx.globalAlpha = 1.0;
            }

            startAnimation() {
                const animate = () => {
                    this.update();
                    this.draw();
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        window.addEventListener('load', () => {
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden';
            
            // éšè—åœ°å€æ ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 0);
            
            // å»¶è¿Ÿåˆå§‹åŒ–ä»¥ç¡®ä¿å°ºå¯¸æ­£ç¡®
            setTimeout(() => {
                const animation = new ChristmasAnimation();
                
                // å­˜å‚¨å¼•ç”¨ä»¥ä¾¿åœ¨æ§åˆ¶å°è°ƒè¯•
                window.christmasAnimation = animation;
                
                // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶é‡ç»˜
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        animation.handleResize();
                    }
                });
            }, 100);
        });

        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                window.scrollTo(0, 0);
                if (window.christmasAnimation) {
                    window.christmasAnimation.handleResize();
                }
            }, 100);
        });

        // é˜²æ­¢åŒå‡»ç¼©æ”¾
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>